<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>ğŸ§‹ê¸€ììˆ˜ ë¶€ë£¨ë§ˆë¸” [PATCHED15-anim-ui-winner-leavefix]</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Jua&family=Nunito:wght@700;800;900&display=swap');
:root{
      --bg:#0f1220;
      --panel:#151a2e;
      --panel2:#101427;
      --line:rgba(255,255,255,.10);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --accent:#ff7cc8;
      --good:#7CFFB2;
      --bad:#FF6B6B;
      --warn:#FFD166;
      --tile:#192042;
      --tile2:#141a35;
      --shadow: 0 10px 24px rgba(0,0,0,.28);
      --r:22px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: "Jua","Nunito","Apple SD Gothic Neo","Noto Sans KR", ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Helvetica Neue", sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:var(--sans);
      background:
        radial-gradient(1200px 600px at 20% -10%, rgba(255,124,200,.30), transparent 60%),
        radial-gradient(900px 500px at 100% 10%, rgba(124,255,178,.18), transparent 60%),
        radial-gradient(1000px 500px at 30% 120%, rgba(255,209,102,.14), transparent 60%),
        var(--bg);
      color:var(--text);
      min-height:100vh;
    }
    a{color:inherit}
    .app{
      max-width:1240px;
      margin:0 auto;
      padding:18px;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:16px;
    }
    @media (max-width: 980px){
      .app{grid-template-columns:1fr; padding:12px}
    }
    .card{
      background:linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .topbar{
      padding:12px 14px;
      display:flex;
      gap:10px;
      align-items:center;
      border-bottom:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.00));
    }
    .title{
      font-weight:800;
      letter-spacing:-.3px;
      display:flex;
      align-items:center;
      gap:10px;
      flex: 1 1 auto;
      min-width:0;
    }
    .pill{
      font-family:var(--mono);
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.20);
      color:var(--muted);
      display:inline-flex;
      gap:8px;
      align-items:center;
      white-space:nowrap;
    }
    .btn{
      border:1px solid var(--line);
      background:rgba(0,0,0,.22);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      transition:transform .06s ease, background .12s ease, border-color .12s ease;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{background:rgba(255,255,255,.06)}
    .btn:active{transform:translateY(1px)}
    .btn.primary{
      border-color: rgba(255,124,200,.40);
      background: rgba(255,124,200,.18);
    }
    .btn.good{
      border-color: rgba(124,255,178,.40);
      background: rgba(124,255,178,.14);
    }
    .btn.bad{
      border-color: rgba(255,107,107,.40);
      background: rgba(255,107,107,.12);
    }
    .btn:disabled{
      opacity:.45;
      cursor:not-allowed;
    }
    .grid{
      display:grid;
      gap:12px;
      padding:14px;
    }
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .row > *{flex: 0 0 auto}
    .field{
      flex:1 1 auto;
      min-width:180px;
      display:flex;
      gap:8px;
      align-items:center;
    }
    input, select{
      width:100%;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.25);
      color:var(--text);
      outline:none;
    }
    input::placeholder{color:rgba(255,255,255,.45)}
    .hint{color:var(--muted); font-size:13px; line-height:1.45}
    .mono{font-family:var(--mono)}
    .split{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    @media (max-width:520px){ .split{grid-template-columns:1fr} }

    /* --- Board --- */
    .boardWrap{padding:14px}
    .board{
      width:100%;
      max-width: 780px;
      margin: 0 auto;
      aspect-ratio: 1 / 1;
      border-radius: 22px;
      border:1px solid var(--line);
      background:linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.16));
      position:relative;
      overflow:hidden;
    }

    .boardGrid{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      grid-template-rows: repeat(7, 1fr);
      gap:6px;
      padding:10px;
    }
    .center{
      grid-column: 2 / span 5;
      grid-row: 2 / span 5;
      border-radius: 18px;
      border:1px dashed rgba(255,255,255,.18);
      background: radial-gradient(400px 220px at 50% 40%, rgba(255,124,200,.14), transparent 70%),
                  radial-gradient(420px 240px at 50% 60%, rgba(124,255,178,.10), transparent 72%),
                  rgba(0,0,0,.18);
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      padding:10px;
      min-width:0;
    }
    .dice{
      width:84px; height:84px;
      border-radius:24px;
      border:1px solid rgba(255,255,255,.20);
      background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(0,0,0,.18));
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:44px;
      font-weight:900;
      box-shadow: 0 12px 26px rgba(0,0,0,.30);
      transform-origin:center;
    }
    .dice.rolling{
      animation: roll .55s ease-in-out infinite;
    }
    .dice.pop{ filter: drop-shadow(0 10px 16px rgba(0,0,0,.28)); }
    .dice.finish{ animation: finishPop .22s ease-out 1; }
    @keyframes finishPop{ 0%{transform:scale(1)} 60%{transform:scale(1.10)} 100%{transform:scale(1)} }
    @keyframes roll{
      0%{transform:rotate(0deg) scale(1)}
      30%{transform:rotate(12deg) scale(1.03)}
      60%{transform:rotate(-10deg) scale(.98)}
      100%{transform:rotate(0deg) scale(1)}
    }
    .centerTop{
      width:100%;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom:10px;
      min-width:0;
    }
    .centerTop .round{
      font-weight:900;
      letter-spacing:-.3px;
      white-space:nowrap;
    }
    .banner{
      width:100%;
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.20);
      font-size:13px;
      color:var(--muted);
      min-width:0;
    }
    .banner b{color:var(--text)}
    .banner .nowrap{
      display:-webkit-box;
      -webkit-box-orient:vertical;
      -webkit-line-clamp:2;
      overflow:hidden;
      display:block;
    }

    .tile{
      border-radius:18px;
      border:1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.18));
      position:relative;
      overflow:hidden;
      padding:6px 7px 20px 7px;
      min-width:0;
    }
    .tile .name{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin:0;
      font-weight:900;
      letter-spacing:.8px;
      line-height:1.15;
      min-width:0;
    }
    .tile .name .tEmoji{
      font-size:20px;
      line-height:1.05;
      margin-bottom:2px;
      filter: drop-shadow(0 2px 5px rgba(0,0,0,.28));
    }
    .tile .name .tLabel{
      font-size:17px;
      line-height:1.18;
      display:-webkit-box;
      -webkit-box-orient:vertical;
      -webkit-line-clamp:2;
      overflow:hidden;
      word-break:keep-all;
      letter-spacing:.6px;
    }
    .tile .name .tSub{
      font-size:13px;
      line-height:1.15;
      opacity:.86;
      letter-spacing:1.0px;
      margin-top:2px;
    }
    .tile .sub{display:none;}
    
    @media (max-width: 520px){
      .tile .name{gap:5px}
      .tile .name .tEmoji{font-size:18px; line-height:1.05; margin-bottom:2px}
      .tile .name .tLabel{font-size:15px; line-height:1.18; letter-spacing:.55px}
      .tile .name .tSub{font-size:12px; line-height:1.15; margin-top:2px}
      .dice{width:72px;height:72px;font-size:38px}
    }
.tile .badge{
      position:absolute; right:7px; top:7px;
      font-size:11px;
      padding:4px 8px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background:rgba(0,0,0,.18);
      color:rgba(255,255,255,.75);
      font-family:var(--mono);
    }
    .tile .ownerBar{
      position:absolute; left:0; right:0; bottom:0;
      height:12px;
      border-top:1px solid rgba(255,255,255,.10);
      background: transparent;
      display:none;
    }
    .tile .tokens{
      position:absolute; left:6px; bottom:14px;
      display:flex;
      gap:0;
      pointer-events:none;
    }
    .token{
      width:26px; height:26px;
      display:flex; align-items:center; justify-content:center;
      font-size:18px;
      filter: drop-shadow(0 2px 5px rgba(0,0,0,.35));
      transform: translateX(var(--dx, 0px)) translateY(var(--dy, 0px));
    }

    .token.me{
      filter: drop-shadow(0 3px 10px rgba(255,124,200,.55)) drop-shadow(0 0 14px rgba(255,124,200,.35));
      transform: translateX(var(--dx, 0px)) translateY(var(--dy, 0px)) scale(1.18);
    }
    .token.moved{
      animation: tokenPop .28s ease-out 1;
    }
    @keyframes tokenPop{
      0%{transform: translateX(var(--dx, 0px)) translateY(var(--dy, 0px)) scale(0.92)}
      60%{transform: translateX(var(--dx, 0px)) translateY(var(--dy, 0px)) scale(1.26)}
      100%{transform: translateX(var(--dx, 0px)) translateY(var(--dy, 0px)) scale(1.12)}
    }

    .tile.current{
      outline:2px solid rgba(255,209,102,.55);
      box-shadow: 0 0 0 4px rgba(255,209,102,.10);
    }

    /* Arrange 24 tiles around outer border in 7x7 grid (center is 5x5) */
    .pos-0  {grid-column:7; grid-row:7;}
    .pos-1  {grid-column:6; grid-row:7;}
    .pos-2  {grid-column:5; grid-row:7;}
    .pos-3  {grid-column:4; grid-row:7;}
    .pos-4  {grid-column:3; grid-row:7;}
    .pos-5  {grid-column:2; grid-row:7;}
    .pos-6  {grid-column:1; grid-row:7;}
    .pos-7  {grid-column:1; grid-row:6;}
    .pos-8  {grid-column:1; grid-row:5;}
    .pos-9  {grid-column:1; grid-row:4;}
    .pos-10 {grid-column:1; grid-row:3;}
    .pos-11 {grid-column:1; grid-row:2;}
    .pos-12 {grid-column:1; grid-row:1;}
    .pos-13 {grid-column:2; grid-row:1;}
    .pos-14 {grid-column:3; grid-row:1;}
    .pos-15 {grid-column:4; grid-row:1;}
    .pos-16 {grid-column:5; grid-row:1;}
    .pos-17 {grid-column:6; grid-row:1;}
    .pos-18 {grid-column:7; grid-row:1;}
    .pos-19 {grid-column:7; grid-row:2;}
    .pos-20 {grid-column:7; grid-row:3;}
    .pos-21 {grid-column:7; grid-row:4;}
    .pos-22 {grid-column:7; grid-row:5;}
    .pos-23 {grid-column:7; grid-row:6;}


    .side{
      padding:14px;
      display:grid;
      gap:12px;
    }
    .section{
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      border-radius:16px;
      overflow:hidden;
    }
    .section .hdr{
      padding:10px 12px;
      border-bottom:1px solid var(--line);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-weight:900;
      letter-spacing:-.3px;
      background:rgba(255,255,255,.04);
    }
    .section .body{padding:10px 12px; display:grid; gap:10px}
    .plist{
      display:grid;
      gap:8px;
    }
    .pitem{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.16);
      border-radius:14px;
    }
    .pitem.me{outline:2px solid rgba(255,124,200,.45)}
    .pitem.dead{opacity:.55; filter:grayscale(.35)}
    .pname{
      display:flex; gap:10px; align-items:center; min-width:0;
    }
    .pname .emoji{font-size:20px}
    .pname .n{
      font-weight:900; letter-spacing:-.2px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
      max-width: 180px;
    }
    .pmeta{
      font-family:var(--mono);
      font-size:12px;
      color:rgba(255,255,255,.74);
      text-align:right;
      white-space:nowrap;
    }
    .log{
      font-family:var(--mono);
      font-size:12px;
      line-height:1.45;
      color:rgba(255,255,255,.78);
      max-height: 260px;
      overflow:auto;
      padding-right:6px;
    }
    .log .line{margin:0 0 6px 0}

    .chatlog{
      font-family:var(--mono);
      font-size:12px;
      line-height:1.45;
      color:rgba(255,255,255,.86);
      max-height: 220px;
      overflow:auto;
      padding-right:6px;
      display:grid;
      gap:6px;
    }
    .chatmsg{
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.14);
      border-radius:14px;
    }
    .chatmsg .m1{display:flex; gap:8px; align-items:center; justify-content:space-between}
    .chatmsg .who{font-weight:900; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .chatmsg .when{opacity:.68; font-size:11px; font-family:var(--mono)}
    .chatmsg .txt{margin-top:4px; color:rgba(255,255,255,.90); word-break:break-word}
    .chatSendRow{display:flex; gap:8px; align-items:center}
    .chatSendRow input{flex:1 1 auto; min-width:0}
    .kpi{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:8px;
    }
    .kpi .box{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(0,0,0,.16);
      border-radius:14px;
      padding:10px;
    }
    .kpi .box .t{font-size:12px; color:rgba(255,255,255,.72)}
    .kpi .box .v{font-family:var(--mono); font-weight:900; font-size:16px; margin-top:4px}
    .toast{
      position:fixed;
      left:50%;
      bottom:16px;
      transform:translateX(-50%);
      padding:10px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.78);
      color:rgba(255,255,255,.90);
      box-shadow: var(--shadow);
      display:none;
      max-width: min(720px, calc(100vw - 24px));
    }
    .toast.show{display:block; animation:pop .18s ease}
    @keyframes pop{from{transform:translateX(-50%) translateY(8px); opacity:.0} to{transform:translateX(-50%) translateY(0); opacity:1}}
    .modalBack{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      z-index:40;
    }
    .modalBack.show{display:flex}
    .modal{
      width:min(680px, 100%);
      border-radius: 18px;
      border:1px solid rgba(255,255,255,.18);
      background: rgba(18, 20, 40, .94);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal .mh{
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.12);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      font-weight:900;
    }
    .modal .mb{
      padding:12px 14px;
      display:grid; gap:10px;
      color: rgba(255,255,255,.94);
    }
    .modal .actions{
      padding:12px 14px;
      border-top:1px solid rgba(255,255,255,.12);
      display:flex; justify-content:flex-end; gap:10px; flex-wrap:wrap;
    }
    .tag{
      display:inline-flex;
      gap:6px;
      align-items:center;
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.20);
      color:rgba(255,255,255,.78);
      font-family:var(--mono);
    }
    .fineprint{font-size:12px; color:rgba(255,255,255,.62)}
    .sep{height:1px; background:rgba(255,255,255,.10)}
  
/* PATCHED20_SAFE: visuals only (no rule changes) */
.tile .name{ font-size: 12px !important; }
.tokenLayer{ position:absolute; inset:0; pointer-events:none; }
.token{
  position:absolute;
  transform: translate(-9999px,-9999px);
  padding:6px 10px;
  border-radius:999px;
  font-weight:700;
  font-size:13px;
  background: rgba(255,255,255,0.10);
  border: 1px solid rgba(255,255,255,0.18);
  backdrop-filter: blur(8px);
  box-shadow: 0 10px 26px rgba(0,0,0,0.22);
  white-space:nowrap;
  transition: transform 0.18s linear;
}
.token.me{
  transform: translate(-9999px,-9999px) scale(1.08);
  border-color: rgba(255, 105, 180, 0.75);
  box-shadow: 0 0 0 2px rgba(255, 105, 180, 0.20), 0 16px 36px rgba(0,0,0,0.28);
}

</style>

  <!-- Firebase (for realtime multiplayer) -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

</head>
<body>
  <div class="app">
    <!-- LEFT: BOARD -->
    <div class="card">
      <div class="topbar">
        <div class="title">
          <span style="font-size:20px">ğŸ™ï¸</span>
          <span>ê¸€ììˆ˜ ë¶€ë£¨ë§ˆë¸”</span>
          <span class="pill" id="pillRoom">ROOM <span class="mono" id="roomIdView">â€”</span></span>
          <span class="pill" id="pillPhase">PHASE <span class="mono" id="phaseView">WAIT</span></span>
        </div>
        <button class="btn" id="btnHelp">ê·œì¹™</button>
        <button class="btn" id="btnLeave">ë°© ë‚˜ê°€ê¸°</button>
        <button class="btn bad" id="btnReset">ë¦¬ì…‹</button>
      </div>

      
      <div class="grid" id="joinPanel">
        <div class="section">
          <div class="hdr">ë¶€ë£¨ë§ˆë¸” ì…ì¥</div>
          <div class="body">
            <div class="row">
              <div class="field"><input id="inpName" placeholder="ë‹‰ë„¤ì„" /></div>
            </div>
            <div class="row">
              <button class="btn primary" id="btnJoin">ğŸ² ì°¸ì—¬(í”Œë ˆì´ì–´)</button>
              <button class="btn" id="btnSpectate">ğŸ‘€ ê´€ì „</button>
            </div>
            <div class="hint">
              âœ… ìˆ˜ë‹¤ë°©ì—ì„œ <b>ë¶€ë£¨ë§ˆë¸”</b>ì„ ëˆ„ë¥´ë©´ ìë™ìœ¼ë¡œ ê°™ì€ ë°©ìœ¼ë¡œ ë“¤ì–´ì™€ìš”.<br/>
              âœ… <b>í”Œë ˆì´ì–´</b>ëŠ” 2~5ëª…, <b>ê´€ì „ì</b>ëŠ” ì¸ì› ì œí•œ ì—†ì´ ì…ì¥ ê°€ëŠ¥!<br/>
              âœ… ì±„íŒ…ì€ <b>í”Œë ˆì´ì–´/ê´€ì „ì ëª¨ë‘</b> ì‚¬ìš© ê°€ëŠ¥ ğŸ’¬
            </div>
          </div>
        </div>
      </div>

      <div class="boardWrap" id="gamePanel" style="display:none;">

        <div class="board">
          <div class="boardGrid" id="boardGrid"><div class="tokenLayer" id="tokenLayer"></div>
            <div class="center">
              <div class="centerTop">
                <div class="round" id="roundView">ë¼ìš´ë“œ 0 / 10</div>
                <span class="tag" id="turnTag">â€”</span>
              </div>
              <div class="dice" id="dice">ğŸ²</div>
              <div class="row" style="margin-top:12px; justify-content:center;">
                <button class="btn primary" id="btnOrderRoll">ì‹œì‘ êµ´ë¦¼</button>
                <button class="btn good" id="btnRoll">êµ´ë¦¬ê¸°</button>
                <button class="btn" id="btnEnd">í„´ ì¢…ë£Œ</button>
              </div>
              <div class="row" style="margin-top:10px; justify-content:center;">
                <button class="btn" id="btnBuy">ë§¤ì…</button>
                <button class="btn" id="btnUpgrade">íœíŠ¸í•˜ìš°ìŠ¤í™”</button>
                <button class="btn" id="btnLoan">ëŒ€ì¶œ</button>
                <button class="btn" id="btnRepay">ìƒí™˜</button>
              </div>
              <div class="banner" id="banner">
                <span class="nowrap">ğŸ’– ì¤€ë¹„ë˜ë©´ <b>ì‹œì‘ êµ´ë¦¼</b>ì„ ëˆŒëŸ¬ ìˆœì„œë¥¼ ì •í•´ìš”.</span>
              </div>
            </div>
            <!-- tiles injected -->
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: SIDE PANEL -->
    <div class="card">
      <div class="topbar">
        <div class="title">
          <span style="font-size:20px">ğŸ§¾</span>
          <span>ìƒíƒœíŒ</span>
        </div>
      </div>

      <div class="side">
        <div class="section">
          <div class="hdr">
            <span>í”Œë ˆì´ì–´</span>
            <span class="pill">ALIVE <span class="mono" id="aliveCount">0</span></span>
          </div>
          <div class="body">
            <div class="kpi">
              <div class="box">
                <div class="t">ë‚´ ë§</div>
                <div class="v" id="meEmoji">â€”</div>
              </div>
              <div class="box">
                <div class="t">ë‚´ ê¸€ììˆ˜</div>
                <div class="v" id="meLetters">â€”</div>
              </div>
            </div>
            <div class="plist" id="plist"></div>
          </div>
        </div>

        <div class="section">
          <div class="hdr">
            <span>ë¡œê·¸</span>
            <span class="pill">LAST <span class="mono" id="lastRoll">â€”</span></span>
          </div>
          <div class="body">
            <div class="log" id="log"></div>
          </div>
        </div>

        
        <div class="section">
          <div class="hdr">
            <span>ì±„íŒ…</span>
            <span class="pill">ROOM <span class="mono" id="chatRoomView">â€”</span></span>
          </div>
          <div class="body">
            <div class="chatlog" id="chatLog"></div>
            <div class="chatSendRow">
              <input id="chatInp" placeholder="ë©”ì‹œì§€â€¦" maxlength="200"/>
              <button class="btn" id="chatSend">ì „ì†¡</button>
            </div>
            <div class="hint">í”Œë ˆì´ì–´/ê´€ì „ì ëª¨ë‘ ì±„íŒ… ê°€ëŠ¥ ğŸ’¬</div>
          </div>
        </div>
<div class="section">
          <div class="hdr">
            <span>ì¹¸ ì •ë³´</span>
            <span class="pill" id="tilePill">â€”</span>
          </div>
          <div class="body">
            <div id="tileInfo" class="hint">ë§ì´ ë©ˆì¶˜ ì¹¸ ì •ë³´ê°€ ì—¬ê¸° ë– ìš”.</div>
          </div>
        </div>

        <div class="fineprint">
          ğŸ’¡ íŒ: ë²„íŠ¼ì´ ì•ˆ ì£½ê²Œ í•˜ë ¤ë©´ â€œí„´ ìƒíƒœ(phase)â€ë¥¼ ì—„ê²©íˆ ë‚˜ëˆ ì•¼ í•´ìš”.<br/>
          ì´ íŒŒì¼ì€ ë©€í‹° ì—°ë™ ì „ì—ë„ ì¬ë¯¸ìˆê²Œ êµ´ëŸ¬ê°€ë„ë¡ <b>ë¡œì»¬ MVP</b>ë¡œ ë§Œë“  ë²„ì „ì…ë‹ˆë‹¤.
        </div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <div class="modalBack" id="modalBack">
    <div class="modal">
      <div class="mh">
        <span id="modalTitle">ì•Œë¦¼</span>
        <button class="btn" id="modalClose">ë‹«ê¸°</button>
      </div>
      <div class="mb" id="modalBody"></div>
      <div class="actions" id="modalActions"></div>
    </div>
  </div>

<script>
(() => {
  /* ===============================
     Cute utilities
  =============================== */
  const $ = (id) => document.getElementById(id);
// ---- ìˆ˜ë‹¤ë°©ì—ì„œ ë„˜ì–´ì˜¨ ê°’: sid(ë°©), u(ë‹‰ë„¤ì„), returnUrl(ë³µê·€), gs(ê²Œì„ì„¸ì…˜) ----
const qp = new URLSearchParams(location.search);
const AUTO_ROOM_ID = (qp.get('sid')||qp.get('roomId')||qp.get('room')||'SUDABANG').trim() || 'SUDABANG';
const AUTO_NAME = (qp.get('u')||qp.get('name')||'').trim();
const RETURN_URL = (qp.get('returnUrl')||qp.get('return')||'').trim();
const GAME_SESSION = (qp.get('gs')||qp.get('game')||'').trim();

// opener(ìˆ˜ë‹¤ë°©)ì—ê²Œ ì•Œë¦¬ê¸° (ê°™ì€ ì¶œì²˜ê°€ ì•„ë‹ˆì–´ë„ postMessageëŠ” ë¨)
function notifyOpener_(type, data){
  try{
    if(window.opener && !window.opener.closed){
      window.opener.postMessage(Object.assign({source:'WRITER_MARBLE', type, roomId: AUTO_ROOM_ID, gs: GAME_SESSION}, data||{}), '*');
    }
  }catch(e){}
}
function closeOrReturn_(){
  // 1) íŒì—…ìœ¼ë¡œ ì—´ë¦° ì°½ì´ë©´ ë‹«ê¸° ì‹œë„
  try{
    if(window.opener && !window.opener.closed){
      window.close();
      // closeê°€ ë§‰íˆëŠ” ë¸Œë¼ìš°ì €ë„ ìˆìœ¼ë‹ˆ fallback
    }
  }catch(e){}
  // 2) ë³µê·€ URLì´ ìˆìœ¼ë©´ ê·¸ìª½ìœ¼ë¡œ ì´ë™
  if(RETURN_URL){
    try{ location.href = RETURN_URL; }catch(e){}
  }
}

const APP_VERSION = "PATCHED14-multiplayer-roomfix";
console.log("BB APP VERSION:", APP_VERSION);
document.title = (document.title||"Burumabul") + " ["+APP_VERSION+"]";

try{
  $("roomIdView").textContent = AUTO_ROOM_ID;
  $("chatRoomView").textContent = AUTO_ROOM_ID;
}catch(e){}

try{
  if($("inpName")){
    // 1) URLì—ì„œ ë„˜ì–´ì˜¨ ë‹‰ë„¤ì„ì´ 'ìµëª…'ì´ ì•„ë‹ˆë©´ ìš°ì„  ì‚¬ìš©
    const qpName = (AUTO_NAME||"").trim();
    if(qpName && qpName !== "ìµëª…"){
      $("inpName").value = qpName;
    }else{
      // 2) URLì´ ë¹„ì—ˆìœ¼ë©´, ë¸Œë¼ìš°ì €ì— ì €ì¥ëœ ë§ˆì§€ë§‰ ë‹‰ë„¤ì„ì„ ë¶ˆëŸ¬ì™€ì„œ *ë¯¸ë¦¬ ì±„ìš°ê¸°ë§Œ* (ìë™ì°¸ì—¬ X)
      const saved = (localStorage.getItem("bb_last_name")||"").trim();
      if(saved && saved !== "ìµëª…") $("inpName").value = saved;
    }

    // 3) 'ìµëª…' / ë¹ˆ ê°’ì´ë©´ ì…ë ¥ì¹¸ì„ ë¹„ì›Œì„œ ë°˜ë“œì‹œ ì…ë ¥í•˜ë„ë¡
    const v = ($("inpName").value||"").trim();
    if(!v || v === "ìµëª…"){
      $("inpName").value = "";
      $("inpName").placeholder = "ë‹‰ë„¤ì„(í•„ìˆ˜)";
    }
  }
}catch(e){}


/* ===============================
   Firebase multiplayer (same room = same board)
   - Host-driven action log:
     everyone pushes actions -> host applies -> state broadcast
=============================== */
const firebaseConfig = {
  apiKey: "AIzaSyAQYp8_sfgHMnH7KsTOdGgpMc1niarZiSs",
  authDomain: "boomboom1009-ae518.firebaseapp.com",
  databaseURL: "https://boomboom1009-ae518-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "boomboom1009-ae518",
  storageBucket: "boomboom1009-ae518.firebasestorage.app",
  messagingSenderId: "954818391824",
  appId: "1:954818391824:web:477eb52436aafdb5d67f95"
};

const NET = {
  enabled: true,
  inited: false,
  uid: null,
  roomId: null,
  isHost: false,
  db: null,
  root: null,
  stateRef: null,
  actionsRef: null,
  metaRef: null,
  chatRef: null,
};

async function netInit_(roomId){
  // Allow retry even if a previous attempt failed
  NET.enabled = true;
  NET.lastError = null;
  if(NET.inited && NET.roomId===roomId) return;

  try{
    if(!firebase.apps || !firebase.apps.length) firebase.initializeApp(firebaseConfig);
  }catch(e){ try{ firebase.initializeApp(firebaseConfig); }catch(_){} }

  NET.db = firebase.database();
  NET.root = NET.db.ref("games/marble/" + roomId);
  NET.stateRef = NET.root.child("state");
  NET.actionsRef = NET.root.child("actions");
  NET.metaRef = NET.root.child("meta");
  NET.chatRef = NET.root.child("chat");
  NET.roomId = roomId;

  try{
    await firebase.auth().signInAnonymously();
    NET.uid = firebase.auth().currentUser && firebase.auth().currentUser.uid;
  }catch(e){
    console.warn("anon auth failed", e);
    // Don't permanently disable multiplayer â€” allow retry on Join/Spectate.
    NET.lastError = e;
    return;
  }

  const hostUidRef = NET.metaRef.child("hostUid");
  const STALE_MS = 15000;

  await hostUidRef.transaction(cur => cur || NET.uid);

  
// Host action pump: attach when I am host (and backfill last N actions).
function startHostPump_(){
  try{
    if(NET._hostPumpOn) return;
    NET._hostPumpOn = true;
    NET._hostChildAdded = (snap) => {
      const a = snap.val();
      if(!a || !a.type) return;
      applyActionAsHost_(snap.key, a);
    };
    // When listener attaches, RTDB will replay existing children (up to last N),
    // so we won't miss early JOIN / ORDER_ROLL actions.
    NET.actionsRef.limitToLast(400).on("child_added", NET._hostChildAdded);
  }catch(e){
    console.warn("host pump attach failed", e);
  }
}
function stopHostPump_(){
  try{
    if(!NET._hostPumpOn) return;
    NET._hostPumpOn = false;
    if(NET._hostChildAdded) NET.actionsRef.off("child_added", NET._hostChildAdded);
  }catch(e){}
}

let _wasHost = false;
NET.metaRef.on("value", snap => {
  const v = snap.val() || {};
  const beat = v.hostBeat || 0;
  const host = v.hostUid || null;
  if(host && host !== NET.uid && Date.now() - beat > STALE_MS){
    hostUidRef.transaction(cur => (cur === host ? NET.uid : cur));
  }
  NET.isHost = (v.hostUid === NET.uid);
  if(NET.isHost && !_wasHost) startHostPump_();
  if(!NET.isHost && _wasHost) stopHostPump_();
  _wasHost = NET.isHost;
});

setInterval(() => {
    if(!NET.enabled) return;
    if(!NET.uid) return;
    if(NET.isHost){
      NET.metaRef.update({ hostUid: NET.uid, hostBeat: firebase.database.ServerValue.TIMESTAMP });
    }
  }, 5000);

  NET.stateRef.on("value", snap => {
    const s = snap.val();
    if(s){
      state = normalizeState_(s, NET.roomId) || newState(NET.roomId);
      local.mode = "FB";
      local.meId = (local.role === "SPECTATOR") ? null : NET.uid;
      $("roomIdView").textContent = state.roomId || NET.roomId;
      $("phaseView").textContent = (state.phase||"WAIT");
      renderAll();

      // GAME_OVER handling: show summary modal once per game, and auto-reset room (host)
      if(state.phase === "GAME_OVER"){
        try{
          const go = state.gameOver || {};
          const alive = Object.values(state.players||{}).filter(p=>p && !p.bankrupt);
          let winner = (go.winnerId && state.players && state.players[go.winnerId]) ? state.players[go.winnerId] : null;
          if(!winner && alive.length){
            alive.sort((a,b)=>(b.letters-a.letters) || ((b.owned?.length||0)-(a.owned?.length||0)));
            winner = alive[0];
          }
          const shownKey = String(go.at||state.resetAt||"") + ":" + String(go.winnerId||"");
          if(local._shownGameOverKey !== shownKey){
            local._shownGameOverKey = shownKey;
            const wname = winner ? winner.name : "â€”";
            const wemo = winner ? winner.emoji : "";
            const reason = go.reason || "ê²Œì„ ì¢…ë£Œ";
            showModal({
              title:"ğŸ ê²Œì„ì´ ëë‚¬ì–´ìš”!",
              body:`<div style="font-size:16px; font-weight:900">ìŠ¹ì: ${wemo} ${wname}</div>
                    <div class="hint">ì‚¬ìœ : <b>${reason}</b></div>
                    <div class="sep"></div>
                    <div class="hint">ë‹¤ìŒ íŒì€ ìë™ìœ¼ë¡œ ìƒˆ ë°©ì²˜ëŸ¼ ì´ˆê¸°í™”ë¼ìš”. (ì•½ 8ì´ˆ)</div>`,
              actions:[{text:"í™•ì¸", kind:"primary", onClick:()=>{}}]
            });
          }
// ğŸ‘‰ ìˆ˜ë‹¤ë°©(ì˜¤í”„ë„ˆ)ë¡œ ìŠ¹ì ì•Œë¦¬ê³ , ê²Œì„ ì°½ ìë™ ì¢…ë£Œ/ë³µê·€
try{
  const go = state.gameOver || {};
  const shownKey = String(go.at||state.resetAt||"") + ":" + String(go.winnerId||"");
  if(local._autoCloseKey !== shownKey){
    local._autoCloseKey = shownKey;
    const alive2 = Object.values(state.players||{}).filter(p=>p && !p.bankrupt);
    let winner2 = (go.winnerId && state.players && state.players[go.winnerId]) ? state.players[go.winnerId] : null;
    if(!winner2 && alive2.length){
      alive2.sort((a,b)=>(b.letters-a.letters) || ((b.owned?.length||0)-(a.owned?.length||0)));
      winner2 = alive2[0];
    }
    notifyOpener_('GAME_OVER', {
      winnerId: winner2 ? winner2.id : null,
      winnerName: winner2 ? winner2.name : null,
      winnerEmoji: winner2 ? winner2.emoji : null,
      reason: go.reason || 'ê²Œì„ ì¢…ë£Œ'
    });

    // âœ… ê²Œì„ ì¢…ë£Œ ì‹œìŠ¤í…œ ë©”ì‹œì§€ë¥¼ 'ê²Œì„ ì±„íŒ…'ì—ë„ 1íšŒ ê¸°ë¡
    try{
      const go = state.gameOver || {};
      const key = String(go.at||state.resetAt||"") + ":" + String(go.winnerId||"");
      if(local._sentWinnerChatKey !== key){
        local._sentWinnerChatKey = key;
        const winnerName = (winner2 && winner2.name) ? winner2.name : (go.winnerId||"ì•Œ ìˆ˜ ì—†ìŒ");
        const winnerEmoji = (winner2 && winner2.emoji) ? winner2.emoji : "ğŸ†";
        const reasonTxt = (go.reason||"ê²Œì„ ì¢…ë£Œ");
        if(NET.chatRef){
          NET.chatRef.push({ts: Date.now(), who:"SYSTEM", sys:true, txt:`ğŸ ê²Œì„ ì¢…ë£Œ! ìŠ¹ì: ${winnerEmoji} ${winnerName} (${reasonTxt})`});
        }
      }
    }catch(e){}
    // 1.2ì´ˆ í›„ ìë™ ë‹«ê¸°/ë³µê·€ (ì‚¬ìš©ìê°€ ëª¨ë‹¬ì„ ë³¼ ì‹œê°„)
    setTimeout(()=>{ try{ closeOrReturn_(); }catch(e){} }, 1200);
  }
}catch(e){}

// ğŸ‘‰ í˜¸ìŠ¤íŠ¸ê°€ ì‚¬ë¼ì¡Œê±°ë‚˜, resetAtì´ ì§€ë‚¬ëŠ”ë°ë„ ì´ˆê¸°í™”ê°€ ì•ˆ ë˜ë©´
//    ëˆ„êµ¬ë“ ì§€ 1íšŒ "ë¦¬ì…‹ ì‹œë„"ë¥¼ í•´ì„œ ë‹¤ìŒ íŒì´ í•­ìƒ ìƒˆë¡œ ì‹œì‘í•˜ê²Œ.
try{
  if(state.resetAt && Date.now() > (state.resetAt + 500) && !local._anyResetTried){
    local._anyResetTried = true;
    // transaction: GAME_OVER ìƒíƒœì¼ ë•Œë§Œ ìƒˆ ìƒíƒœë¡œ êµì²´
    NET.stateRef.transaction(cur=>{
      if(!cur) return;
      if(cur.phase !== 'GAME_OVER') return;
      if(!cur.resetAt) return;
      if(Date.now() <= (cur.resetAt + 200)) return;
      const ns = newState(NET.roomId);
      return ns;
    }, (err, committed)=>{
      if(!err && committed){
        try{ NET.actionsRef.remove(); }catch(e){}
      }
    });
  }
}catch(e){}
        }catch(e){}
        if(NET.isHost && state.resetAt){
          const ms = Math.max(300, (state.resetAt - Date.now()));
          if(!NET._resetTimer){
            NET._resetTimer = setTimeout(()=>{
              NET._resetTimer = null;
              try{
                // wipe actions (prevents huge replay) and reset state
                NET.actionsRef.remove();
                NET.stateRef.set(newState(NET.roomId));
              }catch(e){}
            }, ms);
          }
        }
      }
    }
  });

  // --- Chat (players + spectators) ---
  try{
    if(NET.chatRef){
      NET.chatRef.off();
      NET.chatRef.limitToLast(120).on("child_added", snap => {
        const v = snap.val() || {};
        appendChat_(v);
      });
      $("chatRoomView").textContent = NET.roomId;
    }
  }catch(e){}

  // (host pump attached via meta watcher)

NET.inited = true;
}

function emitAction_(type, payload={}){
  if(!NET.enabled || !NET.inited) return;
  const a = {
    type,
    uid: NET.uid,
    payload: payload||{},
    ts: firebase.database.ServerValue.TIMESTAMP
  };
  return NET.actionsRef.push(a);
}

function applyActionAsHost_(key, a){
  NET.stateRef.transaction(cur => {
    if(!cur) cur = newState(NET.roomId);
    cur = normalizeState_(cur, NET.roomId) || newState(NET.roomId);
    state = cur;
    // --- defensive defaults for older/partial state blobs ---
    if(!state.players) state.players = {};
    if(!state.log) state.log = [];
    if(!state.order) state.order = [];
    if(typeof state.turnIndex !== 'number') state.turnIndex = 0;
    if(!state._lastActionKey) state._lastActionKey = "";
    if(state._lastActionKey >= key) return; // already processed

    const actorUid = a.uid;

    function hostLog(msg){
      (state.log||(state.log=[])).unshift('[' + new Date().toLocaleTimeString('ko-KR') + '] ' + msg);
      if(state.log.length>80) state.log.length=80;
    }

    function makePlayerWithId_(name, pid){
      const p = makePlayer(name);
      p.id = pid;
      return p;
    }

    function isActorsTurn_(){
      if(state.phase!=="PLAY") return false;
      const order = Array.isArray(state.order) ? state.order : [];
      const idx = (typeof state.turnIndex === "number") ? state.turnIndex : 0;
      return (order[idx] === actorUid);
    }

    function rollDeterministic_(){ return rand(1,6); }

    function moveImmediate_(p, steps){
      const n = state.tiles.length;
      p.pos = (p.pos + steps) % n;
    }

    function hostAdvanceTurn_(silent=true){
      if(state.phase!=="PLAY") return;
      const order = Array.isArray(state.order) ? state.order : [];
      if(!order.length) return;
      const prevIndex = (typeof state.turnIndex==="number") ? state.turnIndex : 0;
      state.turnIndex = (prevIndex + 1) % order.length;

      if(prevIndex === order.length - 1){
        state.round = (state.round||0) + 1;
        hostLog('ğŸ“Œ ë¼ìš´ë“œ ì¢…ë£Œ! í˜„ì¬ ' + state.round + ' / ' + ROUNDS_MAX);
        if(state.round > ROUNDS_MAX){
          // Decide winner on host and lock GAME_OVER
          const alive = Object.values(state.players||{}).filter(p=>p && !p.bankrupt);
          if(alive.length){
            alive.sort((a,b)=>(b.letters-a.letters) || ((b.owned?.length||0)-(a.owned?.length||0)));
            state.gameOver = { winnerId: alive[0].id, reason: "10ë¼ìš´ë“œ ì¢…ë£Œ", at: Date.now() };
          }else{
            state.gameOver = { winnerId: null, reason: "ì¢…ë£Œ", at: Date.now() };
          }
          state.phase = "GAME_OVER";
          // schedule reset so the next entry is always fresh
          state.resetAt = Date.now() + 8000;
          return;
        }
      }

      // skip bankrupt
      let guard=0;
      while(guard<20){
        const pid = order[state.turnIndex];
        const p = state.players && state.players[pid];
        if(p && !p.bankrupt) break;
        state.turnIndex = (state.turnIndex + 1) % order.length;
        guard++;
      }
      hostTurnStart_();
    }

    function hostTurnStart_(){
      if(state.phase!=="PLAY") return;
      const order = Array.isArray(state.order) ? state.order : [];
      if(!order.length) return;
      const pid = order[(typeof state.turnIndex==="number")?state.turnIndex:0];
      const p = state.players && state.players[pid];
      if(!p){ return; }
      if(p.bankrupt){
        hostAdvanceTurn_(true);
        return;
      }
      if(p.skip > 0){
        p.skip -= 1;
        hostLog('ğŸ˜µ ' + p.name + ' ìŠ¬ëŸ¼í”„â€¦ ì´ë²ˆ í„´ ì‰¬ê¸° (ë‚¨ì€ ' + p.skip + ')');
        hostAdvanceTurn_(true);
        return;
      }
      state.pending = {
        rolled:false, steps:0, landedTileId:null,
        canBuy:false, canUpgrade:false,
        canLoan:canLoan(p), canRepay:canRepay(p)
      };
    }

    function hostBuy_(uid){
      const p = state.players && state.players[uid];
      if(!p) return;
      const tile = tileAt(p.pos);
      if(tile.type!=="PROPERTY" || tile.owner) return;
      if(p.letters < tile.price) return;
      tile.owner = p.id;
      tile.level = 1;
      p.letters -= tile.price;
      (p.owned||(p.owned=[])).push(tile.id);
      hostLog('ğŸ  ë§¤ì…! ' + tile.name + ' (-' + fmt(tile.price) + 'ì)');
    }
    function hostUpgrade_(uid){
      const p = state.players && state.players[uid];
      if(!p) return;
      const tile = tileAt(p.pos);
      if(tile.type!=="PROPERTY" || tile.owner!==p.id) return;
      const uc = upgradeCost(tile);
      if(uc==null) return;
      if(p.letters < uc) return;
      p.letters -= uc;
      tile.level = (tile.level||1) + 1;
      hostLog('ğŸ› ï¸ íœíŠ¸í•˜ìš°ìŠ¤í™”! ' + tile.name + ' (-' + fmt(uc) + 'ì)');
    }
    function hostLoan_(uid){
      const p = state.players && state.players[uid];
      if(!p) return;
      if(!canLoan(p)) return;
      const amount = 1000;
      p.letters += amount;
      (p.debts||(p.debts=[])).push({amount, ts: Date.now()});
      hostLog('ğŸ¦ ëŒ€ì¶œ +' + fmt(amount) + 'ì');
    }
    function hostRepay_(uid){
      const p = state.players && state.players[uid];
      if(!p) return;
      if(!canRepay(p)) return;
      const d = (p.debts||[]).shift();
      if(!d) return;
      const payAmt = Math.min(p.letters, d.amount);
      p.letters -= payAmt;
      hostLog('ğŸ¦ ìƒí™˜ -' + fmt(payAmt) + 'ì');
    }

    switch(a.type){
      case "JOIN": {
        const name = String(a.payload?.name||"").trim() || "ìµëª…";
        if(!state.players) state.players = {};
        if(Object.keys(state.players||{}).length >= 5 && !state.players[actorUid]) break;

        if(!state.players[actorUid]) {
          const np = makePlayerWithId_(name, actorUid);
          state.players[actorUid] = np;
          if(!state.hostId) state.hostId = actorUid;
          hostLog('ğŸ§‘â€ğŸ’» ' + name + ' ' + np.emoji + ' ì°¸ì—¬! (ì‹œì‘ ' + fmt(START_LETTERS) + 'ì)');
        } else {
          state.players[actorUid].name = name;
        }

        if(Object.keys(state.players||{}).length >= 2 && (state.phase==="WAITING" || state.phase==="WAIT" || !state.phase)) {
          startOrderPhase();
        }
        break;
      }
      case "ORDER_ROLL": {
        // If we are still waiting, allow "ì‹œì‘ êµ´ë¦¼" to also kick off the order-roll phase.
        if(state.phase!=="ORDER_ROLL"){
          const waiting = (state.phase==="WAITING" || state.phase==="WAIT" || !state.phase);
          const pc = Object.keys(state.players||{}).length;
          if(waiting && pc>=2) startOrderPhase();
        }
        if(state.phase!=="ORDER_ROLL") break;
        if(!state.players || !state.players[actorUid]) break;
        const p = state.players[actorUid];
        if(p.orderRoll != null) break;
        const n = rollDeterministic_();
        state.lastRoll = n;
        p.orderRoll = n;
        hostLog('ğŸ² ì‹œì‘ êµ´ë¦¼: ' + p.name + ' = ' + n);
        finalizeOrder();
        break;
      }
      case "ROLL": {
        if(!state.players || !state.players[actorUid]) break;
        if(state.phase!=="PLAY") break;
        if(!isActorsTurn_()) break;
        if(state.pending?.rolled) break;
        const p = state.players[actorUid];
        const n = rollDeterministic_();
        state.lastRoll = n;
        state.pending.rolled = true;
        state.pending.steps = n;
        hostLog('ğŸ² ' + p.name + ' êµ´ë¦¼: ' + n);

        moveImmediate_(p, n);
        const tile = tileAt(p.pos);
        state.pending.landedTileId = tile.id;
        if(tile.type === TileType.START) applyStartLand(p);
        resolveLanding(p, tile);
        // auto-advance if no property decision (buy/upgrade)
        const needChoice = !!(state.pending && (state.pending.canBuy || state.pending.canUpgrade));
        if(!needChoice){
          hostAdvanceTurn_(true);
        }
        break;
      }
      case "BUY": {
        if(!state.players || !state.players[actorUid]) break;
        if(!isActorsTurn_()) break;
        hostBuy_(actorUid);
        // after tile action, auto-advance
        hostAdvanceTurn_(true);
        break;
      }
      case "UPGRADE": {
        if(!state.players || !state.players[actorUid]) break;
        if(!isActorsTurn_()) break;
        hostUpgrade_(actorUid);
        hostAdvanceTurn_(true);
        break;
      }
      case "LOAN": {
        if(!state.players || !state.players[actorUid]) break;
        if(!isActorsTurn_()) break;
        hostLoan_(actorUid);
        // loan is optional; keep turn unless player already rolled and no property decision
        break;
      }
      case "REPAY": {
        if(!state.players || !state.players[actorUid]) break;
        if(!isActorsTurn_()) break;
        hostRepay_(actorUid);
        break;
      }
      case "END": {
        if(!state.players || !state.players[actorUid]) break;
        if(!isActorsTurn_()) break;
        hostAdvanceTurn_(true);
        break;
      }
      case "RESET": {
        if(actorUid !== state.hostId) break;
        state = newState(NET.roomId);
        state._lastActionKey = "";
        break;
      }
    }

    state._lastActionKey = key;
    return state;
  });
}
  const fmt = (n) => (n ?? 0).toLocaleString('ko-KR');
  const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
  const rand = (a,b) => Math.floor(Math.random()*(b-a+1))+a;
  const now = () => new Date().toISOString().slice(11,19);
  const EMOJIS = ["ğŸ±","ğŸ¶","ğŸ¦Š","ğŸ¯","ğŸ¦","ğŸ¼","ğŸ¨","ğŸ¸","ğŸµ","ğŸ¦„","ğŸ™","ğŸ§","ğŸ¤","ğŸ¦‹","ğŸ","ğŸ¢","ğŸ²","ğŸ¦–","ğŸ¦¦","ğŸª¿","ğŸ¦","ğŸ°","ğŸ¹","ğŸ¦•","ğŸ¦’"];

  const COLORS = ["#ff7cc8","#7cffb2","#ffd166","#7cc8ff","#c77dff","#ff6b6b","#a6ff4d","#ff9f1c","#00d1b2"];
  let colorCursor = 0;
  const nextColor = () => COLORS[(colorCursor++) % COLORS.length];


  function beepCute(type="click"){
    try{
      const ctx = beepCute.ctx || (beepCute.ctx = new (window.AudioContext||window.webkitAudioContext)());
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      const t = ctx.currentTime;
      const seq = type==="dice" ? [880, 660, 990, 740] : [880, 740];
      o.type = "triangle";
      g.gain.setValueAtTime(0.0001, t);
      g.gain.exponentialRampToValueAtTime(0.18, t+0.01);
      let tt = t+0.01;
      for(const f of seq){
        o.frequency.setValueAtTime(f, tt);
        tt += 0.05;
      }
      g.gain.exponentialRampToValueAtTime(0.0001, tt+0.08);
      o.start(t);
      o.stop(tt+0.10);
    }catch(e){ /* ignore */ }
  }

  function toast(msg){
    const t = $("toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(toast._tm);
    toast._tm = setTimeout(()=>t.classList.remove("show"), 2200);
  }

  function showModal({title="ì•Œë¦¼", body="", actions=[]} = {}){
    $("modalTitle").textContent = title;
    $("modalBody").innerHTML = body;
    const act = $("modalActions");
    act.innerHTML = "";
    actions.forEach(a=>{
      const b = document.createElement("button");
      b.className = "btn " + (a.kind||"");
      b.textContent = a.text;
      b.onclick = () => { beepCute("click"); try{a.onClick?.()}finally{ if(a.close!==false) hideModal(); } };
      act.appendChild(b);
    });
    $("modalBack").classList.add("show");
  }
  function hideModal(){ $("modalBack").classList.remove("show"); }

  $("modalClose").onclick = () => { beepCute("click"); hideModal(); };
  $("modalBack").addEventListener("click", (e)=>{
    if(e.target === $("modalBack")) hideModal();
  });

  /* ===============================
     Game data
  =============================== */
  const ROUNDS_MAX = 30;
  const START_LETTERS = 15000;

  const TileType = {
    START: "START",
    PROPERTY: "PROPERTY",
    EVENT: "EVENT",
    REST: "REST"
  };

  const PropertyTier = [
    {name:"ì›”ì„¸ë°©",  price: 450,  toll: 170},
    {name:"ì›ë£¸",   price: 650,  toll: 220},
    {name:"ì˜¤í”¼ìŠ¤í…”", price: 850,  toll: 280},
    {name:"íˆ¬ë£¸",   price: 1050, toll: 340},
    {name:"ì•„íŒŒíŠ¸",  price: 1300, toll: 420},
    {name:"ê³ ê¸‰ì•„íŒŒíŠ¸", price: 1650, toll: 520},
  ];

  const Upgrade = [
    {lvl:1, label:"ì›”ì„¸",   costMul: 0.0, tollMul: 1.0},
    {lvl:2, label:"ìê°€",   costMul: 0.55, tollMul: 1.8},
    {lvl:3, label:"íœíŠ¸í•˜ìš°ìŠ¤", costMul: 0.80, tollMul: 2.6},
  ];

  // 24 tiles around border. ids are 0..23
  const BOARD_DEF = [
    {id:0,  type:TileType.START, name:"START", desc:"ì§€ë‚˜ê°€ë©´ +800ì, ë„ì°©í•˜ë©´ +500ì"},

    // â”€â”€ ì•„ë˜ ìˆœì„œëŠ” '7x7 ì™¸ê³½ 1ì¤„'ì— ë§ì¶˜ ì§„í–‰ ìˆœì„œ(ì‹œê³„ë°©í–¥) â”€â”€
    // bottom (7)
    {id:1,  type:TileType.PROPERTY, tier:0, name:"ë°˜ì§€í•˜ ì›”ì„¸"},
    {id:2,  type:TileType.EVENT,    key:"CAFE",   name:"ì¹´í˜ â˜•", desc:"ì§‘ì¤‘? ìˆ˜ë‹¤? ëœë¤!"},
    {id:3,  type:TileType.PROPERTY, tier:1, name:"ëŒ€í•™ê°€ ì›ë£¸"},
    {id:4,  type:TileType.EVENT,    key:"TAX",    name:"ê´€ë¦¬ë¹„ ğŸ§¾", desc:"-300~700ì"},
    {id:5,  type:TileType.PROPERTY, tier:2, name:"ì—­ì„¸ê¶Œ ì˜¤í”¼ìŠ¤í…”"},
    {id:6,  type:TileType.EVENT,    key:"INSP",   name:"ì˜ê° ğŸ’¡", desc:"+ê¸€ììˆ˜ ë³´ë„ˆìŠ¤!"},

    // left (6)
    {id:7,  type:TileType.REST,     key:"SLUMP",  name:"ìŠ¬ëŸ¼í”„ ğŸ˜µ", desc:"ë‹¤ìŒ í„´ ì‰¬ê¸° (1íšŒ)"},
    {id:8,  type:TileType.PROPERTY, tier:3, name:"ì‘ì—…ì‹¤ íˆ¬ë£¸"},
    {id:9,  type:TileType.EVENT,    key:"LIB",    name:"ë„ì„œê´€ ğŸ“š", desc:"ê¾¸ì¤€íˆ ì¨ì§ +800ì"},
    {id:10, type:TileType.PROPERTY, tier:0, name:"ê³¨ëª© ì›”ì„¸"},
    {id:11, type:TileType.PROPERTY, tier:4, name:"ì‹ ì¶• ì•„íŒŒíŠ¸"},
    {id:12, type:TileType.EVENT,    key:"EDITOR", name:"í¸ì§‘ë¶€ í˜¸ì¶œ ğŸ“¨", desc:"ìˆ˜ì •ìš”ì²­ -600ì, ë‹¤ìŒ START ë³´ë„ˆìŠ¤!"},

    // top (6)
    {id:13, type:TileType.PROPERTY, tier:5, name:"ê°•ë³€ë·° ê³ ê¸‰ì•„íŒŒíŠ¸"},
    {id:14, type:TileType.EVENT,    key:"BANK",   name:"ì€í–‰ ğŸ¦", desc:"ëŒ€ì¶œ/ìƒí™˜ íƒ€ì´ë° ì²´í¬"},
    {id:15, type:TileType.EVENT,    key:"COLLAB", name:"ì½œë¼ë³´ ğŸ¤", desc:"ë‹¤ë¥¸ í”Œë ˆì´ì–´ì™€ í•¨ê»˜ +500ì"},
    {id:16, type:TileType.PROPERTY, tier:2, name:"ì´ˆê³ ì¸µ ì˜¤í”¼ìŠ¤í…”"},
    {id:17, type:TileType.EVENT,    key:"DEADLINE", name:"ë§ˆê° â³", desc:"ìì‚°ì— ë”°ë¼ ë³´ë„ˆìŠ¤/ë²Œê¸ˆ"},
    {id:18, type:TileType.PROPERTY, tier:4, name:"ë„ì‹¬ ì•„íŒŒíŠ¸"},

    // right (5)
    {id:19, type:TileType.REST,     key:"MOVE",   name:"ì´ì‚¬ ğŸšš", desc:"ëœë¤ ì´ë™(ì•ìœ¼ë¡œ 1~3ì¹¸)"},
    {id:20, type:TileType.PROPERTY, tier:3, name:"ë³µì¸µ íˆ¬ë£¸"},
    {id:21, type:TileType.EVENT,    key:"BONUS",  name:"ë³´ë„ˆìŠ¤ ğŸ", desc:"+500~1200ì ëœë¤"},
    {id:22, type:TileType.PROPERTY, tier:1, name:"ì‹ ì´Œ ì›ë£¸"},
    {id:23, type:TileType.PROPERTY, tier:5, name:"ìŠ¤ì¹´ì´ë¼ì¸ ê³ ê¸‰ì•„íŒŒíŠ¸"},
  ];

  function makeTileState(def){
    const st = {
      id: def.id,
      type: def.type,
      name: def.name,
      desc: def.desc || "",
      key: def.key || null,
      tier: def.tier ?? null,
      owner: null,      // playerId
      level: 0,         // 0=unowned, 1=ì›”ì„¸, 2=ìê°€, 3=íœíŠ¸í•˜ìš°ìŠ¤
      price: 0,
      baseToll: 0,
    };
    if(def.type === TileType.PROPERTY){
      const tier = PropertyTier[clamp(def.tier ?? 0, 0, PropertyTier.length-1)];
      st.price = tier.price;
      st.baseToll = tier.toll;
    }
    return st;
  }

  /* ===============================
     State
  =============================== */
  let state = null;

  function newState(roomId){
    const tiles = BOARD_DEF.map(makeTileState);
    return {
      roomId,
      phase: "WAITING",   // WAITING, ORDER_ROLL, PLAY, GAME_OVER
      hostId: null,
      createdAt: Date.now(),
      round: 0,           // 0..ROUNDS_MAX
      turnIndex: 0,
      order: [],          // playerIds
      players: {},        // id -> player
      lastRoll: null,
      pending: null,      // pending action info for current player
      log: [],
      tiles,
    };
  }

  // Ensure partially-loaded / older room states don't crash the UI or host logic.
  function normalizeState_(s, roomIdFallback){
    if(!s || typeof s !== "object") return null;
    if(!s.roomId) s.roomId = roomIdFallback || s.roomId || "";
    if(!s.phase) s.phase = "WAITING";
    if(typeof s.turnIndex !== "number") s.turnIndex = 0;
    if(!Array.isArray(s.order)) s.order = [];
    if(!s.players || typeof s.players !== "object") s.players = {};
    if(!Array.isArray(s.log)) s.log = [];
    if(!Array.isArray(s.tiles) || !s.tiles.length){
      try{ s.tiles = BOARD_DEF.map(makeTileState); }catch(e){ s.tiles = s.tiles || []; }
    }

    // --- player defaults (backward compatibility / partial blobs) ---
    for(const [pid, p0] of Object.entries(s.players||{})){
      const p = (p0 && typeof p0 === "object") ? p0 : (s.players[pid] = {});
      if(!p.id) p.id = pid;
      if(typeof p.name !== "string" || !p.name.trim()) p.name = "ìµëª…";
      if(!p.emoji) p.emoji = "ğŸ™‚";
      if(!p.color) p.color = "#888";
      if(typeof p.letters !== "number") p.letters = START_LETTERS;
      if(typeof p.pos !== "number") p.pos = 0;
      if(typeof p.loansUsed !== "number") p.loansUsed = 0;
      if(!Array.isArray(p.debts)) p.debts = [];
      if(typeof p.skip !== "number") p.skip = 0;
      if(p.orderRoll === undefined) p.orderRoll = null;
      if(typeof p.bonusStart !== "number") p.bonusStart = 0;
      if(typeof p.bankrupt !== "boolean") p.bankrupt = false;
      if(!Array.isArray(p.owned)) p.owned = [];
    }

    // pending defaults
    if(!s.pending || typeof s.pending !== "object"){
      s.pending = { rolled:false, steps:0, landedTileId:null, canBuy:false, canUpgrade:false, canLoan:false, canRepay:false };
    }else{
      if(typeof s.pending.rolled !== "boolean") s.pending.rolled = false;
      if(typeof s.pending.steps !== "number") s.pending.steps = 0;
      if(s.pending.landedTileId === undefined) s.pending.landedTileId = null;
    }

    return s;
  }



  function makePlayer(name){
    const id = "p_" + Math.random().toString(36).slice(2,9);
    const emoji = EMOJIS[rand(0, EMOJIS.length-1)];
    const color = nextColor();
    return {
      id,
      name,
      emoji,
      color,
      letters: START_LETTERS,
      pos: 0,
      loansUsed: 0,
      debts: [],       // numbers [3300, 3450] etc
      skip: 0,         // skip turns (slump)
      orderRoll: null,
      bonusStart: 0,   // bonus on next START pass (editor effect)
      bankrupt: false,
      owned: [],
    };
  }

  function alivePlayers(){
    return Object.values(state.players||{}).filter(p=>!p.bankrupt);
  }
  function currentPid(){
    const order = Array.isArray(state.order) ? state.order : [];
    if(!order.length) return null;
    const idx = (typeof state.turnIndex === "number") ? state.turnIndex : 0;
    return order[idx] || null;
  }
  function currentPlayer(){
    const pid = currentPid();
    return pid ? state.players[pid] : null;
  }
  function isMyTurn(){
    return local.meId && local.meId === currentPid();
  }

  /* ===============================
     Local runtime (Hotseat / Solo)
  =============================== */
  const local = {
    mode: "LOCAL",    // LOCAL only in this MVP
    meId: null,
    role: "PLAYER",
  entered: false,
  chatName: "",   // PLAYER | SPECTATOR
  };

  function setState(next){
    state = next;
    renderAll();
  }

  function pushLog(msg){
    (state.log||(state.log=[])).unshift(`[${new Date().toLocaleTimeString('ko-KR')}] ${msg}`);
    if(state.log.length > 80) state.log.length = 80;
    renderLog();
  }

  /* ===============================
     Game logic helpers
  =============================== */
  function setPhase(ph){
    state.phase = ph;
    $("phaseView").textContent = ph;
    renderControls();
  }

  function startOrderPhase(){
    setPhase("ORDER_ROLL");
    state.round = 0;
    state.turnIndex = 0;
    state.order = Object.keys(state.players||{});
    for(const p of Object.values(state.players||{})){
      p.orderRoll = null;
    }
    pushLog("ğŸŸ£ ìˆœì„œ ì •í•˜ê¸°! ëª¨ë‘ 'ì‹œì‘ êµ´ë¦¼'ì„ ëˆŒëŸ¬ìš”.");
    setBanner("ğŸ’– ëª¨ë‘ <b>ì‹œì‘ êµ´ë¦¼</b>ì„ ëˆŒëŸ¬ ìˆœì„œë¥¼ ì •í•´ìš”. í° ìˆ˜ë¶€í„° 1ë“±!");
    renderAll();
  }

  function finalizeOrder(){
    const ps = Object.values(state.players||{});
    const rolled = ps.filter(p=>p.orderRoll!=null);
    if(rolled.length !== ps.length){
      toast("ì•„ì§ ë‹¤ ì•ˆ êµ´ë ¸ì–´ìš”!");
      return;
    }
    const map = new Map();
    for(const p of ps){
      map.set(p.orderRoll, (map.get(p.orderRoll)||[]).concat([p]));
    }
    const tied = [...map.entries()].filter(([k,v])=>v.length>1).sort((a,b)=>b[0]-a[0]);
    if(tied.length){
      const tieNames = tied.map(([r,arr]) => `${r}(${arr.map(x=>x.name).join(", ")})`).join(" / ");
      pushLog(`ğŸŸ¡ ë™ì  ë°œìƒ â†’ ì¬êµ´ë¦¼ ëŒ€ìƒ: ${tieNames}`);
      setBanner(`ğŸŸ¡ ë™ì ! <b>ë™ì ìë§Œ</b> ë‹¤ì‹œ ì‹œì‘ êµ´ë¦¼ì„ ëˆŒëŸ¬ìš”: ${tieNames}`);
      tied.forEach(([r,arr]) => arr.forEach(p => p.orderRoll = null));
      renderAll();
      return;
    }
    const order = ps.slice().sort((a,b)=>b.orderRoll - a.orderRoll).map(p=>p.id);
    state.order = order;
    state.turnIndex = 0;
    state.round = 1;
    setPhase("PLAY");
    pushLog(`ğŸ ìˆœì„œ í™•ì •! ${order.map((id,i)=>`${i+1}ï¸âƒ£ ${state.players[id].name}`).join(" â†’ ")}`);
    setBanner(`ğŸ ê²Œì„ ì‹œì‘! <b>${state.players[order[0]].name}</b> ë‹˜ë¶€í„° ğŸ²`);
    for(const p of Object.values(state.players||{})){
      p.pos = 0; p.letters = START_LETTERS; p.loansUsed = 0; p.debts = [];
      p.skip = 0; p.bonusStart = 0; p.bankrupt = false; p.owned = [];
    }
    for(const t of state.tiles){
      if(t.type === TileType.PROPERTY){
        t.owner = null; t.level = 0;
      }
    }
    state.pending = null;
    renderAll();
    onTurnStart();
  }

  function setBanner(html){
    $("banner").innerHTML = `<span class="nowrap">${html}</span>`;
  }

  function diceRoll(){ return rand(1,6); }

  function animateDice(finalN, cb){
    const d = $("dice");
    d.classList.add("rolling");
    d.classList.add("pop");
    let ticks = 0;
    const faces = ["âš€","âš","âš‚","âšƒ","âš„","âš…"];
    const interval = setInterval(()=>{
      d.textContent = faces[rand(0,5)];
      ticks++;
      if(ticks>=14){
        clearInterval(interval);
        d.classList.remove("rolling");
        d.textContent = faces[Math.max(0, Math.min(5, (finalN||1)-1))];
        // micro-pop finish
        d.classList.add("finish");
        setTimeout(()=>d.classList.remove("finish"), 220);
        cb?.();
      }
    }, 45);
    setTimeout(()=>d.classList.remove("pop"), 260);
  }

  async function moveSteps(pid, steps){
    for(let i=0;i<steps;i++){
      await new Promise(res=>setTimeout(res, 240));
      const p = state.players[pid];
      p.pos = (p.pos + 1) % state.tiles.length;
      if(p.pos === 0) applyStartPass(p);
      renderBoardTokens();
    }
  }

  function applyStartPass(p){
    let add = 800;
    if(p.bonusStart > 0){
      add += p.bonusStart;
      pushLog(`âœ¨ ${p.name} í¸ì§‘ë¶€ ë²„í”„ +${fmt(p.bonusStart)}ì ì¶”ê°€!`);
      p.bonusStart = 0;
    }
    p.letters += add;
    pushLog(`ğŸ¡ ${p.name} START í†µê³¼! +${fmt(add)}ì`);
  }
  function applyStartLand(p){
    p.letters += 500;
    pushLog(`ğŸ¡ ${p.name} START ë„ì°©! +500ì`);
  }

  function tileAt(pos){ return state.tiles[pos]; }

  function calcToll(tile){
    if(tile.type !== TileType.PROPERTY || !tile.owner || tile.level <= 0) return 0;
    const base = tile.baseToll;
    const mul = Upgrade[clamp(tile.level-1, 0, 2)].tollMul;
    return Math.round(base * mul);
  }

  function upgradeCost(tile){
    if(tile.type !== TileType.PROPERTY || tile.owner==null) return null;
    if(tile.level >= 3) return null;
    const nextLevel = tile.level + 1;
    const mul = Upgrade[clamp(nextLevel-1, 0, 2)].costMul;
    return Math.round(tile.price * mul);
  }

  function currentTileInfoHTML(tile){
    if(!tile) return "";
    if(tile.type === TileType.START){
      return `<div><b>ğŸ¡ ${tile.name}</b></div><div class="sep"></div><div class="hint">ì§€ë‚˜ê°€ë©´ <b>+800ì</b>, ë„ì°©í•˜ë©´ <b>+500ì</b></div>`;
    }
    if(tile.type === TileType.REST){
      return `<div><b>ğŸŒ€ ${tile.name}</b></div><div class="sep"></div><div class="hint">${tile.desc||""}</div>`;
    }
    if(tile.type === TileType.EVENT){
      return `<div><b>âœï¸ ${tile.name}</b></div><div class="sep"></div><div class="hint">${tile.desc||""}</div>`;
    }
    const owner = tile.owner ? state.players[tile.owner] : null;
    const lvl = tile.level || 0;
    const lvlLabel = lvl===0 ? "ë¯¸ë§¤ì…" : Upgrade[lvl-1].label;
    const toll = calcToll(tile);
    const upCost = upgradeCost(tile);
    return `
      <div><b>ğŸ  ${tile.name}</b> <span class="tag">${lvlLabel}</span></div>
      <div class="sep"></div>
      <div class="hint">
        ë§¤ì…ê°€: <b>${fmt(tile.price)}ì</b><br/>
        í†µí–‰ë£Œ: <b>${fmt(toll)}ì</b><br/>
        ì†Œìœ ì: <b>${owner ? owner.name+" "+owner.emoji : "â€”"}</b><br/>
        ${upCost!=null ? `ë‹¤ìŒ ì—…ê¸€(íœíŠ¸í•˜ìš°ìŠ¤í™”): <b>${fmt(upCost)}ì</b>` : `ì—…ê¸€: <b>${lvl>=3 ? "ìµœëŒ€ì¹˜" : "â€”"}</b>`}
      </div>
    `;
  }

  function pay(fromP, toP, amount, reason){
    amount = Math.max(0, Math.round(amount));
    if(amount<=0) return;
    fromP.letters -= amount;
    if(toP) toP.letters += amount;
    pushLog(`ğŸ’¸ ${fromP.name} â†’ ${toP?toP.name:"ì€í–‰"} : ${fmt(amount)}ì (${reason})`);
    checkBankruptcy(fromP);
  }

  function checkBankruptcy(p){
    if(p.bankrupt) return;
    if(p.letters >= 0) return;
    p.bankrupt = true;
    p.letters = 0;
    for(const t of state.tiles){
      if(t.type === TileType.PROPERTY && t.owner === p.id){
        t.owner = null; t.level = 0;
      }
    }
    p.owned = [];
    pushLog(`ğŸ’€ ${p.name} íŒŒì‚°! (ì†Œìœ  ì¹¸ ì€í–‰ íšŒìˆ˜)`);
    setBanner(`ğŸ’€ <b>${p.name}</b> íŒŒì‚°! ì‚´ì•„ë‚¨ëŠ” ìê°€ MVPâ€¦`);
    const alive = alivePlayers();
    if(alive.length === 1){
      endGame(alive[0].id, "ë§ˆì§€ë§‰ ìƒì¡´");
    }
  }

  function endGame(winnerId, reason){
    setPhase("GAME_OVER");
    const w = state.players[winnerId];
    pushLog(`ğŸ† ê²Œì„ ì¢…ë£Œ! ìŠ¹ì: ${w.name} ${w.emoji} (${reason})`);
    setBanner(`ğŸ† <b>${w.name}</b> ${w.emoji} ìš°ìŠ¹! <span class="mono">(${reason})</span>`);
    showModal({
      title:"ğŸ† ê²Œì„ ì¢…ë£Œ!",
      body:`<div style="font-size:16px; font-weight:900">ìŠ¹ì: ${w.emoji} ${w.name}</div>
            <div class="hint">ì‚¬ìœ : <b>${reason}</b></div>
            <div class="sep"></div>
            <div class="hint">ìµœì¢… ê¸€ììˆ˜: <b>${fmt(w.letters)}ì</b></div>`,
      actions:[{text:"í™•ì¸", kind:"primary", onClick:()=>{}}]
    });
    renderControls();
  }

  function canLoan(p){ return (!p.bankrupt) && p.loansUsed < 2 && p.letters <= 2000; }
  function canRepay(p){ return p.debts.length > 0 && p.letters >= p.debts[0]; }

  function onTurnStart(){
    if(state.phase !== "PLAY") return;
    const pid = currentPid();
    const p = state.players[pid];
    if(!p || p.bankrupt){ advanceTurn(true); return; }
    if(p.skip > 0){
      p.skip -= 1;
      pushLog(`ğŸ˜µ ${p.name} ìŠ¬ëŸ¼í”„â€¦ ì´ë²ˆ í„´ ì‰¬ê¸° (ë‚¨ì€ ${p.skip})`);
      setBanner(`ğŸ˜µ <b>${p.name}</b> ìŠ¬ëŸ¼í”„! ì´ë²ˆ í„´ ìŠ¤í‚µâ€¦`);
      advanceTurn(true);
      return;
    }
    state.pending = {
      rolled:false, steps:0, landedTileId:null,
      canBuy:false, canUpgrade:false,
      canLoan:canLoan(p), canRepay:canRepay(p)
    };
    setBanner(`ğŸ² <b>${p.name}</b> ë‹˜ ì°¨ë¡€! êµ´ë ¤ì„œ ì›”ì„¸ íƒˆì¶œ ê°€ìâ€¦`);
    renderAll();
  }

  function advanceTurn(silent=false){
    if(state.phase !== "PLAY") return;
    const prevIndex = state.turnIndex;
    state.turnIndex = (state.turnIndex + 1) % (Array.isArray(state.order)?state.order.length:0);
    if(prevIndex === (Array.isArray(state.order)?state.order.length:0) - 1){
      state.round += 1;
      pushLog(`ğŸ“Œ ë¼ìš´ë“œ ì¢…ë£Œ! í˜„ì¬ ${state.round} / ${ROUNDS_MAX}`);
      if(state.round > ROUNDS_MAX){
        const alive = alivePlayers();
        if(alive.length === 1){ endGame(alive[0].id, "ë§ˆì§€ë§‰ ìƒì¡´"); return; }
        alive.sort((a,b)=>b.letters-a.letters || b.owned.length-a.owned.length);
        endGame(alive[0].id, "10ë¼ìš´ë“œ ê¸€ììˆ˜ 1ìœ„");
        return;
      }
    }
    let guard=0;
    while(guard<20){
      const cp = currentPlayer();
      if(cp && !cp.bankrupt) break;
      state.turnIndex = (state.turnIndex + 1) % (Array.isArray(state.order)?state.order.length:0);
      guard++;
    }
    if(!silent) setBanner(`ğŸ‘‰ ë‹¤ìŒ ì°¨ë¡€: <b>${currentPlayer().name}</b>`);
    onTurnStart();
  }

  async function handleRollDice(isOrderRoll=false){
    const p = isOrderRoll ? state.players[local.meId] : currentPlayer();
    if(!p) return;
    if(isOrderRoll){
      if(state.phase !== "ORDER_ROLL") return;
      if(p.orderRoll != null){ toast("ì´ë¯¸ êµ´ë ¸ì–´ìš”!"); return; }
    }else{
      if(state.phase !== "PLAY") return;
      if(!isMyTurn()){ toast("ë‚´ ì°¨ë¡€ê°€ ì•„ë‹ˆì—ìš”!"); return; }
      if(state.pending?.rolled){ toast("ì´ë¯¸ êµ´ë ¸ì–´ìš”!"); return; }
    }

    beepCute("dice");
    const n = diceRoll();
    state.lastRoll = n;
    $("lastRoll").textContent = n;
    animateDice(n, ()=>{});

    if(isOrderRoll){
      p.orderRoll = n;
      pushLog(`ğŸ² ì‹œì‘ êµ´ë¦¼: ${p.name} = ${n}`);
      renderAll();
      setTimeout(()=>finalizeOrder(), 150);
      return;
    }

    state.pending.rolled = true;
    state.pending.steps = n;
    pushLog(`ğŸ² ${p.name} êµ´ë¦¼: ${n}`);
    setBanner(`ğŸ² <b>${p.name}</b> : ${n}ì¹¸ ì´ë™!`);

    await moveSteps(p.id, n);
    const tile = tileAt(p.pos);
    state.pending.landedTileId = tile.id;
    if(tile.type === TileType.START) applyStartLand(p);
    resolveLanding(p, tile);
    renderAll();
    // ë§¤ì…/ì—…ê·¸ë ˆì´ë“œ ì„ íƒì§€ê°€ ì—†ìœ¼ë©´ ìë™ìœ¼ë¡œ ë‹¤ìŒ ì°¨ë¡€
    try{
      const needChoice = !!(state.pending && (state.pending.canBuy || state.pending.canUpgrade));
      if(!needChoice){
        setTimeout(()=>{ try{ advanceTurn(); renderAll(); }catch(e){} }, 220);
      }
    }catch(e){}
  }

  function openCollabPicker(p, amount){
    const others = alivePlayers().filter(x=>x.id !== p.id);
    if(!others.length){ p.letters += Math.round(amount/2); return; }
    const body = `
      <div class="hint">íŒŒíŠ¸ë„ˆë¥¼ ì„ íƒí•˜ë©´ <b>ë‘˜ ë‹¤ +${fmt(amount)}ì</b>!</div>
      <div class="sep"></div>
      <div class="row" style="flex-wrap:wrap">
        ${others.map(o=>`<button class="btn" data-pick="${o.id}">${o.emoji} ${o.name}</button>`).join("")}
      </div>`;
    showModal({title:"ğŸ¤ ì½œë¼ë³´ íŒŒíŠ¸ë„ˆ ì„ íƒ", body, actions:[{text:"ì·¨ì†Œ", onClick:()=>{}}]});
    setTimeout(()=>{
      document.querySelectorAll('[data-pick]').forEach(btn=>{
        btn.onclick = () => {
          beepCute("click");
          const pid = btn.getAttribute("data-pick");
          const o = state.players[pid];
          if(!o || o.bankrupt){ toast("ëŒ€ìƒì´ ì—†ì–´ìš”"); return; }
          p.letters += amount; o.letters += amount;
          pushLog(`ğŸ¤ ì½œë¼ë³´ ì„±ê³µ! ${p.name} & ${o.name} ê°ê° +${fmt(amount)}ì`);
          hideModal(); renderAll();
        };
      });
    }, 0);
  }

  function applyRest(p, tile){
    if(tile.key==="SLUMP"){
      p.skip = Math.max(p.skip, 1);
      pushLog(`ğŸ˜µ ${p.name} ìŠ¬ëŸ¼í”„! ë‹¤ìŒ í„´ ì‰¬ê¸° 1íšŒ`);
      setBanner(`ğŸ˜µ ìŠ¬ëŸ¼í”„! ë‹¤ìŒ í„´ ì‰¬ê¸°â€¦`);
      return;
    }
    if(tile.key==="MOVE"){
      const step = rand(1,3);
      pushLog(`ğŸšš ì´ì‚¬! ì•ìœ¼ë¡œ ${step}ì¹¸ ì´ë™!`);
      setBanner(`ğŸšš ì´ì‚¬! ì•ìœ¼ë¡œ ${step}ì¹¸!`);
      // IMPORTANT: In Firebase(host) mode, do NOT use async animation here.
      // Async movement inside host transaction can cause repeated re-entry / "ë¹™ë¹™ë¹™" loops.
      if(local.mode==="FB" && NET.isHost){
        // immediate movement with START pass handling
        const n = state.tiles.length;
        for(let i=0;i<step;i++){
          p.pos = (p.pos + 1) % n;
          if(p.pos === 0) applyStartPass(p);
        }
        const nt = tileAt(p.pos);
        state.pending.landedTileId = nt.id;
        if(nt.type === TileType.START) applyStartLand(p);
        // prevent accidental nested MOVE loops (just in case)
        state._restMoveDepth = (state._restMoveDepth||0) + 1;
        if(state._restMoveDepth < 3) resolveLanding(p, nt);
        state._restMoveDepth = 0;
        return;
      }
      // Non-host / local mode: keep cute movement animation
      (async()=>{
        await moveSteps(p.id, step);
        const nt = tileAt(p.pos);
        state.pending.landedTileId = nt.id;
        if(nt.type === TileType.START) applyStartLand(p);
        resolveLanding(p, nt);
        renderAll();
      })();
    }
  }

  function applyEvent(p, tile){
    const key = tile.key;
    if(key==="LIB"){ p.letters += 800; pushLog(`ğŸ“š ë„ì„œê´€ +800ì`); setBanner(`ğŸ“š ë„ì„œê´€ ì§‘ì¤‘! +800ì`); return; }
    if(key==="CAFE"){
      const r = rand(1,3);
      if(r===1){ p.letters += 1200; pushLog(`â˜• ì¹´í˜ ì§‘ì¤‘ ëŒ€ë°• +1,200ì`); setBanner(`â˜• ì§‘ì¤‘ ëŒ€ë°•! +1,200ì`); }
      else if(r===2){ p.letters -= 400; pushLog(`â˜• ìˆ˜ë‹¤ë¡œ ë§í•¨ -400ì`); setBanner(`â˜• ìˆ˜ë‹¤ë¡œ ë§í•¨â€¦ -400ì`); checkBankruptcy(p); }
      else { pushLog(`â˜• ì½œë¼ë³´ ì°¬ìŠ¤!`); setBanner(`â˜• ì½œë¼ë³´! íŒŒíŠ¸ë„ˆ ì„ íƒ`); openCollabPicker(p, 500); }
      return;
    }
    if(key==="INSP"){ const add=rand(600,1300); p.letters+=add; pushLog(`ğŸ’¡ ì˜ê° +${fmt(add)}ì`); setBanner(`ğŸ’¡ ì˜ê° í­ë°œ! +${fmt(add)}ì`); return; }
    if(key==="BONUS"){ const add=rand(500,1200); p.letters+=add; pushLog(`ğŸ ë³´ë„ˆìŠ¤ +${fmt(add)}ì`); setBanner(`ğŸ ë³´ë„ˆìŠ¤! +${fmt(add)}ì`); return; }
    if(key==="TAX"){ const sub=rand(300,700); p.letters-=sub; pushLog(`ğŸ§¾ ê´€ë¦¬ë¹„ -${fmt(sub)}ì`); setBanner(`ğŸ§¾ ê´€ë¦¬ë¹„â€¦ -${fmt(sub)}ì`); checkBankruptcy(p); return; }
    if(key==="EDITOR"){ p.letters-=600; p.bonusStart=1000; pushLog(`ğŸ“¨ í¸ì§‘ë¶€ -600ì / ë‹¤ìŒ START +1000ì`); setBanner(`ğŸ“¨ ìˆ˜ì •ìš”ì²­! -600ì / ë‹¤ìŒ START +1000ì`); checkBankruptcy(p); return; }
    if(key==="DEADLINE"){
      let delta=0;
      if(p.letters<=5000) delta=-800;
      else if(p.letters<=15000) delta=-300;
      else delta=+300;
      p.letters += delta;
      pushLog(`â³ ë§ˆê° ${delta>=0?"+":"-"}${fmt(Math.abs(delta))}ì`);
      setBanner(`â³ ë§ˆê°! ${delta>=0?"+":"-"}${fmt(Math.abs(delta))}ì`);
      checkBankruptcy(p);
      return;
    }
    if(key==="COLLAB"){ pushLog(`ğŸ¤ ì½œë¼ë³´ ì¹¸!`); setBanner(`ğŸ¤ ì½œë¼ë³´! íŒŒíŠ¸ë„ˆ ì„ íƒ`); openCollabPicker(p, 500); return; }
    if(key==="BANK"){ pushLog(`ğŸ¦ ì€í–‰ ë°©ë¬¸`); setBanner(`ğŸ¦ ì€í–‰! (ëŒ€ì¶œì€ 2,000ì ì´í•˜ + 2íšŒ)`); return; }
  }

  function resolveLanding(p, tile){
    document.querySelectorAll(".tile").forEach(el=>el.classList.remove("current"));
    const el = document.querySelector(`.tile[data-id="${tile.id}"]`);
    if(el) el.classList.add("current");

    $("tilePill").textContent = `TILE ${tile.id}`;
    $("tileInfo").innerHTML = currentTileInfoHTML(tile);

    state.pending.canBuy = false;
    state.pending.canUpgrade = false;
    state.pending.canLoan = canLoan(p);
    state.pending.canRepay = canRepay(p);

    if(tile.type === TileType.PROPERTY){
      if(!tile.owner){
        state.pending.canBuy = (p.letters >= tile.price);
        setBanner(`ğŸ  <b>${tile.name}</b> ë§¤ì…? (ë§¤ì…ê°€ ${fmt(tile.price)}ì)`);
      }else if(tile.owner === p.id){
        const uc = upgradeCost(tile);
        state.pending.canUpgrade = (uc!=null && p.letters >= uc);
        setBanner(`ğŸ› ï¸ ë‚´ ì§‘! ${state.pending.canUpgrade ? "íœíŠ¸í•˜ìš°ìŠ¤í™” ê°€ëŠ¥!" : "ì—…ê·¸ë ˆì´ë“œ ì¡°ê±´ í™•ì¸"}`);
      }else{
        const ownerP = state.players[tile.owner];
        const toll = calcToll(tile);
        pay(p, ownerP, toll, `${tile.name} í†µí–‰ë£Œ`);
        setBanner(`ğŸ’¸ ${ownerP.name}ì˜ ì§‘! í†µí–‰ë£Œ ${fmt(toll)}ì`);
      }
    }else if(tile.type === TileType.EVENT){
      applyEvent(p, tile);
    }else if(tile.type === TileType.REST){
      applyRest(p, tile);
    }
    renderControls();
  }

  function actBuy(){
    if(state.phase!=="PLAY" || !isMyTurn()) return;
    const p = currentPlayer();
    const tile = tileAt(p.pos);
    if(tile.type!=="PROPERTY" || tile.owner) return;
    if(p.letters < tile.price){ toast("ê¸€ììˆ˜ê°€ ë¶€ì¡±í•´ìš”!"); return; }
    tile.owner = p.id;
    tile.level = 1;
    p.letters -= tile.price;
    p.owned.push(tile.id);
    pushLog(`ğŸ  ë§¤ì…! ${tile.name} (-${fmt(tile.price)}ì)`);
    setBanner(`ğŸ  ë§¤ì… ì™„ë£Œ! ë‚´ ì§‘ ëë‹¤ ğŸ’–`);
    renderAll();
    // ìë™ ë‹¤ìŒ ì°¨ë¡€
    setTimeout(()=>{ try{ advanceTurn(); renderAll(); }catch(e){} }, 120);
  }
  function actUpgrade(){
    if(state.phase!=="PLAY" || !isMyTurn()) return;
    const p = currentPlayer();
    const tile = tileAt(p.pos);
    if(tile.type!=="PROPERTY" || tile.owner!==p.id){ toast("ë‚´ ì§‘ì´ ì•„ë‹ˆì—ìš”!"); return; }
    const uc = upgradeCost(tile);
    if(uc==null){ toast("ì—…ê·¸ë ˆì´ë“œ ë¶ˆê°€"); return; }
    if(p.letters < uc){ toast("ê¸€ììˆ˜ê°€ ë¶€ì¡±í•´ìš”!"); return; }
    p.letters -= uc;
    tile.level += 1;
    pushLog(`ğŸ› ï¸ ì—…ê¸€! ${tile.name} â†’ ${Upgrade[tile.level-1].label} (-${fmt(uc)}ì)`);
    setBanner(`ğŸ› ï¸ ${Upgrade[tile.level-1].label} ë‹¬ì„±!`);
    renderAll();
  }
  function actLoan(){
    if(state.phase!=="PLAY" || !isMyTurn()) return;
    const p = currentPlayer();
    if(!canLoan(p)){ toast("ëŒ€ì¶œ ì¡°ê±´ì´ ì•„ë‹ˆì—ìš”"); return; }
    p.loansUsed += 1;
    const principal = 3000;
    const debt = p.loansUsed===1 ? 3300 : 3450;
    p.letters += principal;
    p.debts.push(debt);
    pushLog(`ğŸ¦ ëŒ€ì¶œ! +${fmt(principal)}ì (ìƒí™˜ ${fmt(debt)}ì)`);
    setBanner(`ğŸ¦ ëŒ€ì¶œ ì™„ë£Œ!`);
    renderAll();
  }
  function actRepay(){
    if(state.phase!=="PLAY" || !isMyTurn()) return;
    const p = currentPlayer();
    if(!canRepay(p)){ toast("ìƒí™˜ ë¶ˆê°€"); return; }
    const debt = p.debts.shift();
    p.letters -= debt;
    pushLog(`âœ… ìƒí™˜! -${fmt(debt)}ì`);
    setBanner(`âœ… ìƒí™˜ ì™„ë£Œ!`);
    checkBankruptcy(p);
    renderAll();
  }
  function actEndTurn(){
    if(state.phase!=="PLAY" || !isMyTurn()) return;
    if(!state.pending?.rolled){
      showModal({
        title:"í„´ ì¢…ë£Œ í™•ì¸",
        body:`<div class="hint">ì•„ì§ ì£¼ì‚¬ìœ„ë¥¼ ì•ˆ êµ´ë ¸ì–´ìš”. ê·¸ë˜ë„ í„´ ì¢…ë£Œí• ê¹Œìš”?</div>`,
        actions:[
          {text:"êµ´ë¦´ë˜!", kind:"good", onClick:()=>{}, close:true},
          {text:"ê·¸ë˜ë„ ì¢…ë£Œ", kind:"bad", onClick:()=>{ advanceTurn(); }, close:true},
        ]
      });
      return;
    }
    advanceTurn();
  }

  /* ===============================
     Render
  =============================== */
  function renderControls(){
    const ph = state.phase;
    const my = local.meId && state.players[local.meId];
    const waiting = (!ph || ph==="WAIT" || ph==="WAITING");
    const pc = Object.keys(state.players||{}).length;
    const canStartOrder = waiting && pc>=2;
    // Show "ì‹œì‘ êµ´ë¦¼" both during ORDER_ROLL and when waiting with enough players (host can kick it off).
    $("btnOrderRoll").style.display = (ph==="ORDER_ROLL" || canStartOrder) ? "" : "none";
    $("btnRoll").style.display = (ph==="PLAY") ? "" : "none";
    $("btnEnd").style.display = (ph==="PLAY") ? "" : "none";

    const isMy = ph==="PLAY" && isMyTurn();
    const pend = state.pending || {};

        $("btnOrderRoll").disabled = (ph==="ORDER_ROLL")
      ? !(my && my.orderRoll==null)
      : !(canStartOrder && NET && NET.isHost);
    try{
      $("btnOrderRoll").textContent = "ğŸ² ì‹œì‘ êµ´ë¦¼";
      $("btnOrderRoll").title = (ph==="ORDER_ROLL")
        ? "ìˆœì„œ ì •í•˜ê¸°: ì•„ì§ ì•ˆ êµ´ë¦° ì‚¬ëŒë§Œ ëˆŒëŸ¬ìš”"
        : (canStartOrder ? (NET && NET.isHost ? "í˜¸ìŠ¤íŠ¸ê°€ ìˆœì„œ ì •í•˜ê¸°ë¥¼ ì‹œì‘í•´ìš”" : "í˜¸ìŠ¤íŠ¸ë§Œ ì‹œì‘í•  ìˆ˜ ìˆì–´ìš”") : "í”Œë ˆì´ì–´ 2ëª… ì´ìƒ í•„ìš”");
    }catch(e){}
    $("btnRoll").disabled = !(isMy && !pend.rolled);
    $("btnEnd").disabled = !(isMy);

    $("btnBuy").disabled = !(isMy && pend.canBuy);
    $("btnUpgrade").disabled = !(isMy && pend.canUpgrade);
    $("btnLoan").disabled = !(isMy && pend.canLoan);
    $("btnRepay").disabled = !(isMy && pend.canRepay);
  }

  function renderLog(){
    $("log").innerHTML = state.log.map(x=>`<div class="line">${escapeHtml(x)}</div>`).join("");
  }
  function escapeHtml(s){
    return String(s).replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
  }

  function fmtChatTime(ts){
    try{
      const d = new Date(ts || Date.now());
      return d.toLocaleTimeString('ko-KR', {hour:'2-digit', minute:'2-digit'});
    }catch(e){ return ""; }
  }

  function appendChat_(m){
    const box = $("chatLog");
    if(!box) return;
    const name = escapeHtml(String(m.name||"ìµëª…").slice(0,14));
    const role = m.role === "SPECTATOR" ? "ê´€ì „" : "í”Œë ˆì´";
    const when = fmtChatTime(m.ts);
    const txt = escapeHtml(String(m.text||"").slice(0,200));
    if(!txt) return;

    const div = document.createElement("div");
    div.className = "chatmsg";
    div.innerHTML = `<div class="m1"><span class="who">${name} <span style="opacity:.7">(${role})</span></span><span class="when">${when}</span></div><div class="txt">${txt}</div>`;
    box.appendChild(div);

    // keep at most 140 msgs
    while(box.children.length > 140) box.removeChild(box.firstChild);
    box.scrollTop = box.scrollHeight;
  }

  async function sendChat_(){
    const inp = $("chatInp");
    if(!inp) return;
    const text = (inp.value||"").trim();
    if(!text) return;
    if(!NET.enabled || !NET.inited || !NET.chatRef){ toast("ì±„íŒ… ì—°ê²°ì´ ì•„ì§ì´ì—ìš”!"); return; }
    const name = (local.chatName || ensureName() || (AUTO_NAME || "ìµëª…"));
    const role = local.role === "SPECTATOR" ? "SPECTATOR" : "PLAYER";
    inp.value = "";
    try{
      await NET.chatRef.push({
        uid: NET.uid || null,
        name,
        role,
        text: text.slice(0,200),
        ts: firebase.database.ServerValue.TIMESTAMP
      });
    }catch(e){
      console.warn(e);
      toast("ì±„íŒ… ì „ì†¡ ì‹¤íŒ¨â€¦");
    }
  }

  function renderSide(){
    $("aliveCount").textContent = alivePlayers().length;
    const me = local.meId;
    if(me && state.players[me]){
      $("meEmoji").textContent = state.players[me].emoji;
      $("meLetters").textContent = `${fmt(state.players[me].letters)}ì`;
    }else{
      $("meEmoji").textContent = "â€”";
      $("meLetters").textContent = "â€”";
    }

    const ordered = state.order?.length ? state.order.map(id=>state.players[id]).filter(Boolean) : Object.values(state.players||{});
    $("plist").innerHTML = ordered.map(p=>{
      const isTurn = (p.id === currentPid());
      const debts = (p.debts||[]).reduce((a,b)=>a+b, 0);
      const cls = ["pitem", p.id===me ? "me":"", p.bankrupt?"dead":""]
        .filter(Boolean).join(" ");
      return `
        <div class="${cls}">
          <div class="pname">
            <span class="emoji">${p.emoji}</span>
            <div class="n">${isTurn ? "ğŸ‘‰ " : ""}${escapeHtml(p.name)}</div>
          </div>
          <div class="pmeta">
            ${p.bankrupt ? "ğŸ’€ íŒŒì‚°" : `${fmt(p.letters)}ì`}<br/>
            ğŸ ${p.owned.length} / ğŸ¦${p.loansUsed} / ğŸ’³${fmt(debts)}
          </div>
        </div>`;
    }).join("");
  }


  function formatTileLabel(t){
    // ê¸°ë³¸: 1ì¤„(ì´ëª¨ì§€) + 2ì¤„(ì´ë¦„) + (ì„ íƒ) 3ì¤„(ì„œë¸Œ)
    if(t.type === TileType.START){
      return { emoji:"ğŸ¡", label:"START", sub:"(ì…ì£¼)" };
    }
    const raw = (t.name || "").trim();

    // ì´ë¦„ì— í¬í•¨ëœ ì´ëª¨ì§€ë¥¼ ì²« ì¤„ë¡œ ë¹¼ê¸°
    let emoji = null;
    try{
      const m = raw.match(/\p{Extended_Pictographic}/u);
      if(m) emoji = m[0];
    }catch(e){
      // ì¼ë¶€ êµ¬í˜• ë¸Œë¼ìš°ì € fallback
      const m = raw.match(/[\u{1F300}-\u{1FAFF}]/u);
      if(m) emoji = m[0];
    }

    let label = raw;
    try{
      label = raw.replace(/\p{Extended_Pictographic}/gu, "").replace(/\s{2,}/g," ").trim();
    }catch(e){
      label = raw.replace(/[\u{1F300}-\u{1FAFF}]/gu, "").replace(/\s{2,}/g," ").trim();
    }
    if(!label) label = raw;

    // ì´ë¦„ì— ì´ëª¨ì§€ê°€ ì—†ìœ¼ë©´: íƒ€ì…/í‹°ì–´ ê¸°ë°˜ ê¸°ë³¸ ì´ëª¨ì§€
    if(!emoji){
      if(t.type === TileType.PROPERTY){
        const tier = clamp(t.tier ?? 0, 0, 5);
        emoji = ["ğŸšï¸","ğŸ›ï¸","ğŸ¢","ğŸ§‘â€ğŸ’»","ğŸ ","ğŸ™ï¸"][tier] || "ğŸ ";
      }else if(t.type === TileType.EVENT){
        emoji = "âœï¸";
      }else if(t.type === TileType.REST){
        emoji = "ğŸŒ€";
      }else{
        emoji = "ğŸ§©";
      }
    }

    return { emoji, label, sub:"" };
  }

  
  // ===============================
  // PATCHED20_SAFE: token layer + step movement (client-side animation)
  // ===============================
  const tokenAnim = { prevPos: {}, timers: {} };

  function tileCenterForPos(pos){
    const el = document.querySelector(`.tile.pos-${pos}`);
    const grid = $("boardGrid");
    if(!el || !grid) return null;
    const r = el.getBoundingClientRect();
    const gr = grid.getBoundingClientRect();
    const cx = (r.left + r.right)/2 - gr.left;
    const cy = (r.top + r.bottom)/2 - gr.top;
    // pull towards inner track (vector to center) to make an "inner path"
    const gcx = (gr.width)/2;
    const gcy = (gr.height)/2;
    const vx = (gcx - cx);
    const vy = (gcy - cy);
    const k = 0.22;
    return { x: cx + vx*k, y: cy + vy*k };
  }

  function ensureToken(uid, isMe){
    const layer = $("tokenLayer");
    if(!layer) return null;
    let t = layer.querySelector(`.token[data-uid="${uid}"]`);
    if(!t){
      t = document.createElement("div");
      t.className = "token";
      t.setAttribute("data-uid", uid);
      layer.appendChild(t);
    }
    if(isMe) t.classList.add("me"); else t.classList.remove("me");
    return t;
  }

  function animateTokenSteps(uid, fromPos, toPos){
    const p = (state.players||{})[uid];
    if(!p) return;
    const N = state.tiles?.length || 1;
    const steps = (toPos - fromPos + N) % N;

    // short step animation only; otherwise teleport (prevents crazy loops)
    if(steps===0 || steps>12){
      const c = tileCenterForPos(toPos);
      const t = ensureToken(uid, uid===local.meId);
      if(c && t) t.style.transform = `translate(${c.x}px, ${c.y}px)`;
      tokenAnim.prevPos[uid] = toPos;
      return;
    }

    if(tokenAnim.timers[uid]){
      tokenAnim.timers[uid].forEach(id=>clearTimeout(id));
      tokenAnim.timers[uid]=null;
    }
    const tids=[];
    for(let i=1;i<=steps;i++){
      const pos=(fromPos+i)%N;
      tids.push(setTimeout(()=>{
        const c=tileCenterForPos(pos);
        const t=ensureToken(uid, uid===local.meId);
        if(c && t) t.style.transform = `translate(${c.x}px, ${c.y}px)`;
        if(i===steps) tokenAnim.prevPos[uid]=toPos;
      }, i*220));
    }
    tokenAnim.timers[uid]=tids;
  }

  function updateTokenLayer(){
    const players = state.players || {};
    for(const [uid,p] of Object.entries(players)){
      if(!p || p.bankrupt) continue;
      const t = ensureToken(uid, uid===local.meId);
      if(!t) continue;
      t.textContent = (p.avatar||"ğŸ™‚") + " " + p.name;
      const prev = (tokenAnim.prevPos[uid]===undefined) ? p.pos : tokenAnim.prevPos[uid];
      if(prev !== p.pos){
        animateTokenSteps(uid, prev, p.pos);
      }else{
        const c=tileCenterForPos(p.pos);
        if(c) t.style.transform = `translate(${c.x}px, ${c.y}px)`;
      }
    }
  }

function renderBoard(){
    const grid = $("boardGrid");
    if(!renderBoard._done){
      for(const t of state.tiles){
        const div = document.createElement("div");
        div.className = `tile pos-${t.id}`;
        div.setAttribute("data-id", t.id);
        div.innerHTML = `
          <div class="badge">${t.type==="PROPERTY" ? "ğŸ " : t.type==="EVENT" ? "âœï¸" : t.type==="REST" ? "ğŸŒ€" : "ğŸ¡"}</div>
          <div class="name"></div>
          <div class="sub"></div>
          <div class="tokens"></div>
          <div class="ownerBar"></div>`;
        div.onclick = () => {
          beepCute("click");
          const tile = state.tiles[t.id];
          $("tilePill").textContent = `TILE ${tile.id}`;
          $("tileInfo").innerHTML = currentTileInfoHTML(tile);
          toast(tile.name);
        };
        grid.appendChild(div);
      }
      renderBoard._done = true;
    }

    for(const t of state.tiles){
      const div = document.querySelector(`.tile[data-id="${t.id}"]`);
      if(!div) continue;
      const nameEl = div.querySelector(".name");
      const lab = formatTileLabel(t);
            const subHtml = lab.sub ? `<div class="tSub">${escapeHtml(lab.sub)}</div>` : "";
      nameEl.innerHTML = `<div class="tEmoji">${lab.emoji}</div><div class="tLabel">${escapeHtml(lab.label)}</div>` + subHtml;
      if(t.type === TileType.PROPERTY){
        const owner = t.owner ? state.players[t.owner] : null;

        // ë³´ë“œíŒì—ëŠ” 'ì´ë¦„ë§Œ' í¬ê²Œ (ì„¸ë¶€ ì •ë³´ëŠ” ìš°ì¸¡ 'ì¹¸ ì •ë³´'ì—ì„œ í™•ì¸)
        div.querySelector(".sub").textContent = "";

        // ì†Œìœ /ë¯¸ë§¤ì…ì€ ìƒ‰ìœ¼ë¡œë§Œ í‘œí˜„: ë¯¸ë§¤ì…=ê¸°ë³¸, ë§¤ì…=í”Œë ˆì´ì–´ ê³ ìœ ìƒ‰ ìŠ¤íŠ¸ë¦½ + ë°°ê²½ í‹´íŠ¸
        const ob = div.querySelector(".ownerBar");
        if(owner && t.level>0){
          ob.style.display = "block";
          ob.style.background = owner.color;
          div.style.borderColor = owner.color + "66"; // alpha
          div.style.background =
            `linear-gradient(180deg, rgba(255,255,255,.06), rgba(0,0,0,.22)),
             radial-gradient(360px 180px at 30% 18%, ${owner.color}33, transparent 62%),
             radial-gradient(360px 180px at 70% 80%, ${owner.color}22, transparent 62%)`;
        }else{
          ob.style.display = "none";
          div.style.borderColor = "rgba(255,255,255,.10)";
          div.style.background = `linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.18))`;
        }
      } else {
        div.querySelector(".sub").textContent = "";
        const ob = div.querySelector(".ownerBar");
        ob.style.display = "none";
        div.style.borderColor = "rgba(255,255,255,.10)";
        div.style.background = `linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.18))`;
      }
    }
    renderBoardTokens();
  }

  
function renderBoardTokens(){
    // Track position changes for a tiny "move pop" animation (visual only)
    local._prevPos = local._prevPos || {};
    const prev = local._prevPos;

    // Clear
    document.querySelectorAll(".tile .tokens").forEach(x=>x.innerHTML="");

    const posMap = new Map();
    for(const p of Object.values(state.players||{})){
      if(p.bankrupt) continue;
      const arr = posMap.get(p.pos) || [];
      arr.push(p);
      posMap.set(p.pos, arr);
    }

    for(const [pos, arr] of posMap.entries()){
      const holder = document.querySelector(`.tile[data-id="${pos}"] .tokens`);
      if(!holder) continue;

      arr.forEach((p, idx)=>{
        const t = document.createElement("div");
        const was = prev[p.id];
        const moved = (was != null && was !== p.pos);
        t.className = "token" + (p.id===local.meId ? " me" : "") + (moved ? " moved" : "");

        const dx = (idx%3) * 12;
        const dy = Math.floor(idx/3) * -10;
        t.style.setProperty("--dx", dx+"px");
        t.style.setProperty("--dy", dy+"px");
        t.textContent = p.emoji;
        holder.appendChild(t);
      });
    }

    // Update prev positions
    for(const p of Object.values(state.players||{})){
      if(!p) continue;
      prev[p.id] = p.pos;
    }
      try{ updateTokenLayer(); }catch(e){}
}

  function renderAll(){
    $("roomIdView").textContent = state?.roomId || "â€”";
    $("phaseView").textContent = state?.phase || "WAIT";
    $("pillRoom").style.display = state?.roomId ? "inline-flex" : "none";

    // join panel should stay available for latecomers while the game is still joinable (WAITING / ORDER_ROLL)
    const joinable = !!state && (state.phase === "WAITING" || state.phase === "ORDER_ROLL");
    const showJoin = (!local.entered) || (state && state.phase === "GAME_OVER");
    $("joinPanel").style.display = showJoin ? "" : "none";
    $("gamePanel").style.display = showJoin ? "none" : "grid";

    $("roundView").textContent = `ë¼ìš´ë“œ ${state.round} / ${ROUNDS_MAX}`;
    const cp = currentPlayer();
    $("turnTag").textContent = cp ? `TURN: ${cp.name}` : "â€”";
    $("lastRoll").textContent = state.lastRoll ?? "â€”";

    renderBoard();
    renderSide();
    renderLog();
    renderControls();
  }

  /* ===============================
     UI wiring
  =============================== */
  function ensureRoomId(){
    // ìˆ˜ë‹¤ë°©ì—ì„œ ë„˜ì–´ì˜¨ sid/roomì„ ê¸°ë³¸ ë°© ì½”ë“œë¡œ ì‚¬ìš©
    const base = (AUTO_ROOM_ID || "SUDABANG").trim() || "SUDABANG";
    // âœ… gs(ê²Œì„ì„¸ì…˜)ê°€ ìˆìœ¼ë©´ ë°© í‚¤ì— í¬í•¨í•´ì„œ 'í•­ìƒ ìƒˆ íŒ'ì„ ë³´ì¥
    const gs = (GAME_SESSION||"").trim();
    const rid = base; // âœ… ëª¨ë‘ ê°™ì€ sid ë°©ìœ¼ë¡œ ë™ê¸°í™” (gsëŠ” í‘œì‹œìš©/ìºì‹œìš°íšŒìš©ìœ¼ë¡œë§Œ ì‚¬ìš©)
    return rid.toUpperCase();
  }
  function ensureName(){

    const name = ($("inpName").value || "").trim();
    return name ? name.slice(0,14) : null;
  }

  if($("btnNewRoom")) $("btnNewRoom").onclick = () => { toast("ì´ ë²„ì „ì€ ìˆ˜ë‹¤ë°© ìë™ë°©ë§Œ ì‚¬ìš©í•´ìš” ğŸ™‚"); };

  $("btnJoin").onclick = async () => {
  beepCute("click");
  local.role = "PLAYER";
  const rid = ensureRoomId();
  const name = ensureName();
  if(!name || name==="ìµëª…"){ toast("ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì¤˜! (ìµëª… ë§ê³ !)"); return; }
  try{ localStorage.setItem("bb_last_name", name); }catch(e){}

  await netInit_(rid);
  if(!NET.enabled){ toast("ë©€í‹° ì—°ê²° ì‹¤íŒ¨â€¦"); return; }

  $("joinPanel").style.display = "none";
  $("gamePanel").style.display = "grid";
  $("roomIdView").textContent = rid;
  $("chatRoomView").textContent = rid;

  local.entered = true;
  local.chatName = name;
  emitAction_("JOIN", {name});
  setBanner(`ğŸ”— ë©€í‹° ì—°ê²° ì™„ë£Œ! (roomId=${rid})`);
};

$("btnSpectate").onclick = async () => {
  beepCute("click");
  local.role = "SPECTATOR";
  const name = ensureName();
  if(!name || name==="ìµëª…"){ toast("ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì¤˜! (ê´€ì „ë„ ë‹‰ë„¤ì„ í•„ìˆ˜!)"); return; }
  try{ localStorage.setItem("bb_last_name", name); }catch(e){}
  local.chatName = name;
  local.entered = true;
  const rid = ensureRoomId();
  await netInit_(rid);
  if(!NET.enabled){ toast("ë©€í‹° ì—°ê²° ì‹¤íŒ¨â€¦"); return; }

  // ê´€ì „ì€ í”Œë ˆì´ì–´ë¡œ JOINí•˜ì§€ ì•ŠìŒ (ì±„íŒ…ì€ ê°€ëŠ¥)
  local.meId = null;

  $("joinPanel").style.display = "none";
  $("gamePanel").style.display = "grid";
  $("roomIdView").textContent = rid;
  $("chatRoomView").textContent = rid;

  setBanner(`ğŸ‘€ ê´€ì „ ëª¨ë“œ! (roomId=${rid})`);
};

// chat UI
if($("chatSend")) $("chatSend").onclick = () => { beepCute("click"); sendChat_(); };
if($("chatInp")) $("chatInp").addEventListener("keydown", (e)=>{ if(e.key==="Enter"){ e.preventDefault(); sendChat_(); } });

// auto connect to the same room immediately (so spectators can chat too)
(async () => {
  const rid = ensureRoomId();
  try{
    $("roomIdView").textContent = rid;
    $("chatRoomView").textContent = rid;
  }catch(e){}
  await netInit_(rid);

  // ìë™ ì°¸ì—¬(ì˜¤í† ì¡°ì¸) ë¹„í™œì„±í™”: ë‹‰ë„¤ì„ ì…ë ¥ì„ ë°˜ë“œì‹œ ê±°ì¹˜ë„ë¡ í•¨
})();

  if($("btnLocalStart")) $("btnLocalStart").onclick = () => { toast("ë¡œì»¬ ëª¨ë“œëŠ” ì œê±°ë˜ì—ˆì–´ìš” ğŸ™‚"); };

  // Multiplayer: everyone emits actions, host applies and broadcasts state
$("btnOrderRoll").onclick = () => {
  beepCute("dice");
  if(local.mode==="FB"){
    if($("btnOrderRoll").dataset.busy==="1") return;
    $("btnOrderRoll").dataset.busy="1";
    const fake = rand(1,6);
    animateDice(fake, ()=>{
      emitAction_("ORDER_ROLL", {});
      $("btnOrderRoll").dataset.busy="0";
    });
    return;
  }
  return handleRollDice(true);
};
$("btnRoll").onclick = () => {
  beepCute("dice");
  if(local.mode==="FB"){
    if($("btnRoll").dataset.busy==="1") return;
    $("btnRoll").dataset.busy="1";
    const fake = rand(1,6);
    animateDice(fake, ()=>{
      emitAction_("ROLL", {});
      $("btnRoll").dataset.busy="0";
    });
    return;
  }
  return handleRollDice(false);
};
$("btnBuy").onclick = () => { beepCute("click"); if(local.mode==="FB") return emitAction_("BUY", {}); actBuy(); };
$("btnUpgrade").onclick = () => { beepCute("click"); if(local.mode==="FB") return emitAction_("UPGRADE", {}); actUpgrade(); };
$("btnLoan").onclick = () => { beepCute("click"); if(local.mode==="FB") return emitAction_("LOAN", {}); actLoan(); };
$("btnRepay").onclick = () => { beepCute("click"); if(local.mode==="FB") return emitAction_("REPAY", {}); actRepay(); };
$("btnEnd").onclick = () => { beepCute("click"); if(local.mode==="FB") return emitAction_("END", {}); actEndTurn(); };
$("btnLeave").onclick = () => { beepCute("click"); try{ notifyOpener_("LEAVE", {name: local.chatName||local.meId||""}); }catch(e){} try{ closeOrReturn_(); }catch(e){} };

  // Hotseat: current player controls
  const _renderAll = renderAll;
  renderAll = function(){
    if(local.mode==="LOCAL" && state.phase==="PLAY"){
      local.meId = currentPid();
    }
    _renderAll();
  };

  $("btnHelp").onclick = () => {
    beepCute("click");
    showModal({
      title:"ğŸ“œ ê·œì¹™ (10ë¼ìš´ë“œ / íœíŠ¸í•˜ìš°ìŠ¤í™”)",
      body:`
        <div class="hint">
          âœ… ì¸ì›: <b>2~5ëª…</b><br/>
          âœ… ì‹œì‘ ìì‚°: <b>${fmt(START_LETTERS)}ì</b><br/>
          âœ… ìˆœì„œ: ëª¨ë‘ <b>ì‹œì‘ êµ´ë¦¼</b> â†’ í° ìˆ˜ë¶€í„° (ë™ì ì€ ë™ì ì ì¬êµ´ë¦¼)<br/>
          âœ… ë¼ìš´ë“œ: <b>${ROUNDS_MAX}</b> ë¼ìš´ë“œ ì¢…ë£Œê¹Œì§€ ìƒì¡´í•˜ë©´ <b>ê¸€ììˆ˜ 1ìœ„</b> ìŠ¹ë¦¬<br/>
          âœ… íŒŒì‚°ì´ ë°œìƒí•˜ë©´: íŒŒì‚°í•˜ì§€ ì•Šê³  <b>ë§ˆì§€ë§‰ ìƒì¡´</b>ì´ MVP ìŠ¹ë¦¬<br/><br/>
          ğŸ  ë¶€ë™ì‚°:
          <ul style="margin:6px 0 0 18px">
            <li>ë¹„ì–´ìˆìœ¼ë©´ ë§¤ì… ê°€ëŠ¥ (ë§¤ì…í•˜ë©´ <b>ì›”ì„¸</b> ìƒíƒœ)</li>
            <li>ë‚´ ì§‘ì´ë©´ <b>íœíŠ¸í•˜ìš°ìŠ¤í™”</b>(ì—…ê¸€) ê°€ëŠ¥ (ì›”ì„¸â†’ìê°€â†’íœíŠ¸í•˜ìš°ìŠ¤)</li>
            <li>ë‚¨ì˜ ì§‘ ë°Ÿìœ¼ë©´ <b>í†µí–‰ë£Œ</b>ë¥¼ ê¸€ììˆ˜ë¡œ ì§€ê¸‰</li>
          </ul>
          ğŸ¦ ëŒ€ì¶œ:
          <ul style="margin:6px 0 0 18px">
            <li>ê¸€ììˆ˜ <b>2,000ì ì´í•˜</b> + <b>ìµœëŒ€ 2íšŒ</b></li>
            <li>ëŒ€ì¶œ +3,000ì / ìƒí™˜ 1íšŒì°¨ 3,300ì, 2íšŒì°¨ 3,450ì</li>
          </ul>
        </div>`,
      actions:[{text:"í™•ì¸", kind:"primary", onClick:()=>{}}]
    });
  };

  $("btnReset").onclick = () => {
    beepCute("click");
    showModal({
      title:"ë¦¬ì…‹",
      body:`<div class="hint">ì •ë§ ë¦¬ì…‹í• ê¹Œìš”? í˜„ì¬ ì§„í–‰ì´ ì‚¬ë¼ì ¸ìš”.</div>`,
      actions:[
        {text:"ì·¨ì†Œ", onClick:()=>{}},
        {text:"ë¦¬ì…‹", kind:"bad", onClick:()=>{
          if(local.mode==="FB"){ emitAction_("RESET", {}); toast("ë¦¬ì…‹ ìš”ì²­!"); return; }
          state = null;
          local.meId = null;
          renderBoard._done = false;
          document.querySelectorAll("#boardGrid .tile").forEach(x=>x.remove());
          if($("inpRoom")) $("inpRoom").value = "";
          $("inpName").value = "";
          $("roomIdView").textContent = "â€”";
          $("phaseView").textContent = "WAIT";
          $("joinPanel").style.display = "";
          $("gamePanel").style.display = "none";
          toast("ë¦¬ì…‹ ì™„ë£Œ");
          setState(newState("â€”"));
        }}
      ]
    });
  };

  // bootstrap
  setState(newState("â€”"));
  renderAll();


  // ---- join UI ê°•ì œ ë³´ì¥: ë‚´ uidê°€ ì•„ì§ playersì— ì—†ìœ¼ë©´ joinPanelì„ ìœ ì§€ ----
  try{
    const saved = (localStorage.getItem("bb_last_name")||"").trim();
    if($("inpName") && !($("inpName").value||"").trim() && saved && saved!=="ìµëª…"){
      $("inpName").value = saved;
    }
    if($("joinPanel")) $("joinPanel").style.display = "block";
    if($("gamePanel")) $("gamePanel").style.display = "none";
  }catch(e){}
})();</script>
</body>
</html>
